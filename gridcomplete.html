<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Grid Complete - Classic Mode</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #1a1a2e;
    }
    #game-container {
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }
  </style>
</head>

<body>
<div id="game-container"></div>

<script>
/* ------------------------------------------------ */
/* GLOBAL DATA                                      */
/* ------------------------------------------------ */

let VALID_WORDS = new Set();
let WORDS_LOADED = false;

const COLORS = [
  0xFF6B6B,0xFECA57,0x48DBFB,0x1DD1A1,0xEE5A6F,
  0xC44569,0xF97F51,0x5F27CD,0x00D2D3,0x54A0FF
];

/* ------------------------------------------------ */
/* LOAD WORDS                                      */
/* ------------------------------------------------ */

fetch('https://raw.githubusercontent.com/Sublime-Audio-Productions/public-policies/main/assets/words.json')
  .then(r => r.json())
  .then(data => {
    VALID_WORDS = new Set(data);
    WORDS_LOADED = true;
  })
  .catch(() => {
    VALID_WORDS = new Set(['cat','dog','bat','rat','mat','hat','sat','pat']);
    WORDS_LOADED = true;
  });

/* ------------------------------------------------ */
/* UTIL                                             */
/* ------------------------------------------------ */

function drawBricks(scene, w, h) {
  const g = scene.add.graphics();
  for (let y = 0; y < h; y += 40) {
    for (let x = 0; x < w; x += 80) {
      const off = (y / 40) % 2 === 0 ? 0 : 40;
      g.fillStyle(0x1e3a5f);
      g.fillRect(x + off, y, 76, 36);
      g.lineStyle(2, 0x2d5a8f);
      g.strokeRect(x + off, y, 76, 36);
    }
  }
}

/* ------------------------------------------------ */
/* CLASSIC MODE SCENE                               */
/* ------------------------------------------------ */

class ClassicModeScene extends Phaser.Scene {
  constructor() {
    super('ClassicMode');
    this.gridSize = 5;
    this.grid = [];
    this.cells = [];
    this.cellTexts = [];
    this.cellColors = [];
    this.selectedCell = null;
    this.startingCell = null;
    this.uiScale = 1;
  }

  create() {
    if (!WORDS_LOADED) {
      this.add.text(300, 400, 'Loading...', { color: '#fff' }).setOrigin(0.5);
      this.time.delayedCall(100, () => this.create());
      return;
    }

    const { width, height } = this.cameras.main;
    this.uiScale = Math.min(width, height) / 750;

    drawBricks(this, width, height);

    /* ---------- RESERVED SPACE ---------- */
    this.keyboardHeight = height * 0.28;
    this.buttonHeight = 60 * this.uiScale;
    this.topPadding = height * 0.14;

    /* ---------- GRID LAYOUT ---------- */
    const availableHeight =
      height - this.keyboardHeight - this.buttonHeight - this.topPadding - 20;

    this.cellSize = Math.floor(
      Math.min(
        availableHeight / this.gridSize,
        width * 0.9 / this.gridSize
      )
    );

    this.startX = (width - this.cellSize * this.gridSize) / 2;
    this.startY =
      this.topPadding +
      (availableHeight - this.cellSize * this.gridSize) / 2;

    this.initGrid();
    this.createGrid();
    this.createCheckButton();
    this.createKeyboard();
  }

  initGrid() {
    this.grid = Array.from({ length: this.gridSize }, () =>
      Array(this.gridSize).fill('')
    );
    this.selectedCell = [0, 0];
  }

  createGrid() {
    for (let r = 0; r < this.gridSize; r++) {
      this.cells[r] = [];
      this.cellTexts[r] = [];
      this.cellColors[r] = [];

      for (let c = 0; c < this.gridSize; c++) {
        const x = this.startX + c * this.cellSize;
        const y = this.startY + r * this.cellSize;
        const size = this.cellSize * 0.92;

        this.cellColors[r][c] =
          COLORS[Phaser.Math.Between(0, COLORS.length - 1)];

        const cell = this.add
          .rectangle(x, y, size, size, 0x2d3561)
          .setOrigin(0)
          .setInteractive();

        cell.setStrokeStyle(3 * this.uiScale, 0x1a1a2e);

        const text = this.add
          .text(x + size / 2, y + size / 2, '', {
            fontFamily: 'Arial Black',
            fontSize: `${Math.floor(size * 0.45)}px`,
            color: '#fff',
            stroke: '#000',
            strokeThickness: 4
          })
          .setOrigin(0.5);

        cell.on('pointerdown', () => this.selectCell(r, c));

        this.cells[r][c] = cell;
        this.cellTexts[r][c] = text;
      }
    }
  }

  selectCell(r, c) {
    if (this.selectedCell) {
      const [pr, pc] = this.selectedCell;
      this.cells[pr][pc].setStrokeStyle(3 * this.uiScale, 0x1a1a2e);
    }
    this.selectedCell = [r, c];
    this.cells[r][c].setStrokeStyle(5 * this.uiScale, 0xfeca57);
  }

  typeLetter(letter) {
    if (!this.selectedCell) return;
    const [r, c] = this.selectedCell;
    this.grid[r][c] = letter;
    this.cellTexts[r][c].setText(letter);
    this.cells[r][c].setFillStyle(this.cellColors[r][c]);
  }

  deleteLetter() {
    if (!this.selectedCell) return;
    const [r, c] = this.selectedCell;
    this.grid[r][c] = '';
    this.cellTexts[r][c].setText('');
    this.cells[r][c].setFillStyle(0x2d3561);
  }

  /* ---------- CHECK BUTTON ---------- */

  createCheckButton() {
    const { width, height } = this.cameras.main;
    const y =
      height - this.keyboardHeight - this.buttonHeight / 2 - 10;

    const btn = this.add
      .rectangle(width / 2, y, width * 0.7, this.buttonHeight, 0x1dd1a1)
      .setInteractive();

    btn.setStrokeStyle(4 * this.uiScale, 0x10ac84);

    this.add.text(width / 2, y, 'CHECK SOLUTION âœ“', {
      fontFamily: 'Arial Black',
      fontSize: `${Math.floor(20 * this.uiScale)}px`,
      color: '#fff',
      stroke: '#000',
      strokeThickness: 4
    }).setOrigin(0.5);
  }

  /* ---------- QWERTY KEYBOARD ---------- */

  createKeyboard() {
    const { width, height } = this.cameras.main;

    const ROWS = [
      ['Q','W','E','R','T','Y','U','I','O','P'],
      ['A','S','D','F','G','H','J','K','L'],
      ['Z','X','C','V','B','N','M']
    ];

    const keyGap = 8 * this.uiScale;
    const keySize = Math.floor(
      Math.min((width - keyGap * 12) / 10, this.keyboardHeight / 4)
    );

    const startY = height - this.keyboardHeight + keySize / 2;

    ROWS.forEach((row, r) => {
      const rowWidth = row.length * keySize + (row.length - 1) * keyGap;
      const startX = (width - rowWidth) / 2;

      row.forEach((letter, i) => {
        const x = startX + i * (keySize + keyGap) + keySize / 2;
        const y = startY + r * (keySize + keyGap);

        const key = this.add
          .rectangle(x, y, keySize, keySize, COLORS[r])
          .setInteractive();

        key.setStrokeStyle(2 * this.uiScale, 0x1a1a2e);

        this.add.text(x, y, letter, {
          fontFamily: 'Arial Black',
          fontSize: `${Math.floor(keySize * 0.5)}px`,
          color: '#fff',
          stroke: '#000',
          strokeThickness: 3
        }).setOrigin(0.5);

        key.on('pointerdown', () => this.typeLetter(letter));
      });
    });

    /* DELETE */
    const delY = startY + 3 * (keySize + keyGap);
    const delKey = this.add
      .rectangle(width / 2, delY, keySize * 2.6, keySize, 0xff6b6b)
      .setInteractive();

    delKey.setStrokeStyle(3 * this.uiScale, 0xee5a6f);

    this.add.text(width / 2, delY, 'DELETE', {
      fontFamily: 'Arial Black',
      fontSize: `${Math.floor(keySize * 0.45)}px`,
      color: '#fff',
      stroke: '#000',
      strokeThickness: 3
    }).setOrigin(0.5);

    delKey.on('pointerdown', () => this.deleteLetter());
  }
}

/* ------------------------------------------------ */
/* GAME CONFIG                                      */
/* ------------------------------------------------ */

new Phaser.Game({
  type: Phaser.AUTO,
  parent: 'game-container',
  width: Math.min(600, window.innerWidth),
  height: Math.min(800, window.innerHeight),
  backgroundColor: '#1a1a2e',
  scene: [ClassicModeScene],
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH
  }
});
</script>
</body>
</html>