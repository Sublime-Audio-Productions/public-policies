<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Complete - Classic Mode</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #1a1a2e; }
        #game-container { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script>
        let VALID_WORDS = new Set();
        const COLORS = [0xFF6B6B,0xFECA57,0x48DBFB,0x1DD1A1,0xEE5A6F,0xC44569,0xF97F51,0x5F27CD,0x00D2D3,0x54A0FF];
    let WORDS_LOADED = false;

  async function loadWords() {
  try {
    const urls = [
      'https://raw.githubusercontent.com/jonathanwelton/word-lists/main/3-letter-words.json',
      'https://raw.githubusercontent.com/jonathanwelton/word-lists/main/4-letter-words.json',
      'https://raw.githubusercontent.com/jonathanwelton/word-lists/main/5-letter-words.json',
    ];

    const responses = await Promise.all(urls.map(url => fetch(url)));

    const dataArrays = await Promise.all(responses.map(res => {
      if (!res.ok) throw new Error(`Failed to fetch ${res.url}: ${res.status}`);
      return res.json();
    }));

    // merge all words
    const allWords = dataArrays.flat();
    VALID_WORDS = new Set(allWords);
    WORDS_LOADED = true;
    console.log(`Loaded ${VALID_WORDS.size} words (3â€“5 letters)`);

  } catch (error) {
    console.error('Error loading words:', error);
    alert(`Failed to load dictionary: ${error.message}`);
    // fallback...
    VALID_WORDS = new Set(['cat','dog','bat','rat']);
    WORDS_LOADED = true;
  }
}

loadWords();
  
    // Daily challenges - in production, this would be loaded from a JSON file
    const DAILY_CHALLENGES = {
        "2025-01-15": {
            "3": { letter: "W", row: 1, col: 1 },
            "4": { letter: "S", row: 0, col: 2 },
            "5": { letter: "T", row: 2, col: 2 },
            "6": { letter: "R", row: 1, col: 3 }
        },
        "2025-01-16": {
            "3": { letter: "C", row: 0, col: 0 },
            "4": { letter: "A", row: 2, col: 1 },
            "5": { letter: "D", row: 3, col: 3 },
            "6": { letter: "M", row: 2, col: 4 }
        },
        "2025-01-17": {
            "3": { letter: "T", row: 2, col: 2 },
            "4": { letter: "B", row: 1, col: 0 },
            "5": { letter: "P", row: 0, col: 4 },
            "6": { letter: "L", row: 3, col: 2 }
        }
    };

    function getTodayDate() {
        const now = new Date();
        return now.toISOString().split('T')[0];
    }

    function getDailyChallengeData(date, gridSize) {
        const challenges = DAILY_CHALLENGES[date];
        return challenges ? challenges[gridSize.toString()] : null;
    }

    function isDailyChallengeCompleted(date, gridSize) {
        const key = `daily_${date}_${gridSize}`;
        return localStorage.getItem(key) === 'completed';
    }

    function markDailyChallengeCompleted(date, gridSize) {
        const key = `daily_${date}_${gridSize}`;
        localStorage.setItem(key, 'completed');
    }

    function drawBricks(scene, w, h) {
        const g = scene.add.graphics();
        for(let y=0; y<h; y+=40) {
            for(let x=0; x<w; x+=80) {
                const off = (y/40)%2===0 ? 0 : 40;
                g.fillStyle(0x1e3a5f, 1);
                g.fillRect(x+off, y, 76, 36);
                g.lineStyle(2, 0x2d5a8f);
                g.strokeRect(x+off, y, 76, 36);
            }
        }
    }

    class ClassicModeScene extends Phaser.Scene {
        constructor() {
            super('ClassicMode');
            this.gridSize = 5;
            this.grid = [];
            this.cells = [];
            this.cellTexts = [];
            this.cellColors = [];
            this.selectedCell = null;
            this.startingCell = null;
            this.solutionGrid = null;
            this.cellSize = 0;
            this.startX = 0;
            this.startY = 0;
            this.uiScale = 1;
            this.isDailyMode = false;
            this.isFreeMode = false;
            this.todayDate = getTodayDate();
        }

        init(data) {
            this.gridSize = data.gridSize || 5;
            this.isDailyMode = data.isDailyMode || false;
            this.isFreeMode = data.isFreeMode || false;
        }

        create() {
            // Wait for words to load
            if(!WORDS_LOADED) {
                this.add.text(this.cameras.main.width/2, this.cameras.main.height/2, 'Loading words...', {
                    fontSize: '24px',
                    color: '#ffffff'
                }).setOrigin(0.5);
                
                this.time.delayedCall(100, () => this.create());
                return;
            }

            const {width, height} = this.cameras.main;
            const minDim = Math.min(width, height);
            this.uiScale = minDim / 750;

            drawBricks(this, width, height);

            const titleHeight = height * 0.12;
            this.add.rectangle(width/2, titleHeight/2, width, titleHeight, 0x2d3561);

            const titleText = this.isDailyMode ? 'DAILY CHALLENGE' : (this.isFreeMode ? 'FREE MODE' : 'CLASSIC MODE');
            this.add.text(width/2, titleHeight*0.35, titleText, {
                fontFamily: 'Arial Black',
                fontSize: `${Math.floor(32*this.uiScale)}px`,
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: Math.floor(6*this.uiScale)
            }).setOrigin(0.5);

            if(this.isDailyMode) {
                // Show date
                this.add.text(width/2, titleHeight*0.7, this.todayDate, {
                    fontFamily: 'Arial',
                    fontSize: `${Math.floor(14*this.uiScale)}px`,
                    color: '#feca57'
                }).setOrigin(0.5);
            } else {
                this.createGridSizeSelector(width/2, titleHeight*0.75);
            }

            // Calculate layout - keyboard flush at bottom, check button above it
            const keyboardHeight = height * 0.28; // Larger keyboard area
            const checkButtonHeight = 65 * this.uiScale;
            const checkButtonMargin = height * 0.015;
            
            const availableGridHeight = height - titleHeight - keyboardHeight - checkButtonHeight - checkButtonMargin - (height * 0.04);
            
            this.cellSize = Math.floor(
                Math.min(availableGridHeight / this.gridSize, width * 0.9 / this.gridSize)
            );

            this.startX = (width - this.cellSize * this.gridSize) / 2;
            // Center the grid vertically in available space
            const topSpace = titleHeight + height * 0.02;
            const gridHeight = this.cellSize * this.gridSize;
            const bottomSpace = height - keyboardHeight - checkButtonHeight - checkButtonMargin;
            this.startY = topSpace + (bottomSpace - topSpace - gridHeight) / 2;

            this.generateValidGrid();
            
            if(this.isDailyMode) {
                this.setupDailyChallenge();
            } else if(this.isFreeMode) {
                this.setupFreeMode();
            } else {
                this.pickRandomStartingLetter();
            }
            
            this.createGrid();
            this.createBackButton();
            this.createMenuButton();
            this.createCheckButton();
            this.createKeyboard();
        }

        createGridSizeSelector(x, y) {
            const buttonWidth = 55*this.uiScale;  // Bigger buttons
            const spacing = 15*this.uiScale;      // More spacing
            const sizes = [3,4,5,6];
            const startX = x - ((sizes.length*buttonWidth + (sizes.length-1)*spacing)/2);

            sizes.forEach((size, i) => {
                const btnX = startX + i*(buttonWidth+spacing) + buttonWidth/2;
                const isSelected = size === this.gridSize;

                const btn = this.add.rectangle(btnX, y, buttonWidth, buttonWidth*0.85, 
                    isSelected ? 0x1dd1a1 : 0x64748b).setInteractive();
                btn.setStrokeStyle(3*this.uiScale, isSelected ? 0x10ac84 : 0x475569);

                this.add.text(btnX, y, `${size}Ã—${size}`, {  // Using Ã— symbol
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(18*this.uiScale)}px`,  // Bigger text
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(3*this.uiScale)
                }).setOrigin(0.5);

                btn.on('pointerdown', () => {
                    if(size !== this.gridSize) {
                        this.scene.restart({
                            gridSize: size, 
                            isDailyMode: this.isDailyMode,
                            isFreeMode: this.isFreeMode
                        });
                    }
                });

                // Hover effect
                btn.on('pointerover', () => {
                    if(size !== this.gridSize) {
                        this.tweens.add({targets: btn, scaleX: 1.1, scaleY: 1.1, duration: 100});
                    }
                });

                btn.on('pointerout', () => {
                    this.tweens.add({targets: btn, scaleX: 1, scaleY: 1, duration: 100});
                });
            });
        }

        generateValidGrid() {
            const wordsArray = Array.from(VALID_WORDS).filter(w => w.length === this.gridSize);
            
            if(wordsArray.length === 0) {
                this.grid = Array.from({length: this.gridSize}, () => Array(this.gridSize).fill(''));
                return;
            }

            let attempts = 100;
            let success = false;
            let solutionGrid = null;

            for(let attempt = 0; attempt < attempts && !success; attempt++) {
                const tempGrid = Array.from({length: this.gridSize}, () => Array(this.gridSize).fill(''));

                for(let r = 0; r < this.gridSize; r++) {
                    const word = Phaser.Math.RND.pick(wordsArray);
                    for(let c = 0; c < this.gridSize; c++) {
                        tempGrid[r][c] = word[c].toUpperCase();
                    }
                }

                let allColumnsValid = true;
                for(let c = 0; c < this.gridSize; c++) {
                    const colWord = tempGrid.map(row => row[c]).join('').toLowerCase();
                    if(!VALID_WORDS.has(colWord)) {
                        allColumnsValid = false;
                        break;
                    }
                }

                if(allColumnsValid) {
                    success = true;
                    solutionGrid = tempGrid;
                }
            }

            if(success) {
                this.solutionGrid = solutionGrid;
                this.grid = Array.from({length: this.gridSize}, () => Array(this.gridSize).fill(''));
            } else {
                this.grid = Array.from({length: this.gridSize}, () => Array(this.gridSize).fill(''));
            }
        }

        pickRandomStartingLetter() {
            if(!this.solutionGrid) {
                const r = Phaser.Math.Between(0, this.gridSize-1);
                const c = Phaser.Math.Between(0, this.gridSize-1);
                this.startingCell = [r, c];
                this.grid[r][c] = String.fromCharCode(65 + Phaser.Math.Between(0, 25));
            } else {
                const r = Phaser.Math.Between(0, this.gridSize-1);
                const c = Phaser.Math.Between(0, this.gridSize-1);
                
                this.startingCell = [r, c];
                this.grid[r][c] = this.solutionGrid[r][c];
            }

            for(let row = 0; row < this.gridSize; row++) {
                for(let col = 0; col < this.gridSize; col++) {
                    if(row !== this.startingCell[0] || col !== this.startingCell[1]) {
                        this.selectedCell = [row, col];
                        return;
                    }
                }
            }
        }

        setupDailyChallenge() {
            const challengeData = getDailyChallengeData(this.todayDate, this.gridSize);
            
            if(!challengeData || !this.solutionGrid) {
                // Fallback to random if no challenge data
                this.pickRandomStartingLetter();
                return;
            }

            const {letter, row, col} = challengeData;
            
            // Use the specified starting position
            this.startingCell = [row, col];
            this.grid[row][col] = letter.toUpperCase();

            // Select first empty cell
            for(let r = 0; r < this.gridSize; r++) {
                for(let c = 0; c < this.gridSize; c++) {
                    if(r !== row || c !== col) {
                        this.selectedCell = [r, c];
                        return;
                    }
                }
            }
        }

        setupFreeMode() {
            // No starting letter - completely empty grid
            this.startingCell = null;
            // Select top-left cell by default
            this.selectedCell = [0, 0];
        }

        createGrid() {
            for(let r = 0; r < this.gridSize; r++) {
                this.cells[r] = [];
                this.cellTexts[r] = [];
                this.cellColors[r] = [];

                for(let c = 0; c < this.gridSize; c++) {
                    const x = this.startX + c*this.cellSize;
                    const y = this.startY + r*this.cellSize;
                    const size = this.cellSize * 0.92;

                    this.cellColors[r][c] = COLORS[Phaser.Math.Between(0, COLORS.length-1)];

                    this.add.rectangle(x+4*this.uiScale, y+4*this.uiScale, size, size, 0x000000, 0.3).setOrigin(0);

                    const isStartingCell = this.startingCell && this.startingCell[0]===r && this.startingCell[1]===c;

                    const cell = this.add.rectangle(x, y, size, size,
                        this.grid[r][c] ? this.cellColors[r][c] : 0x2d3561).setOrigin(0);

                    cell.setStrokeStyle(
                        isStartingCell ? 4*this.uiScale : 3*this.uiScale,
                        isStartingCell ? 0xfeca57 : 0x1a1a2e
                    );
                    cell.setInteractive();

                    const text = this.add.text(x+size/2, y+size/2, this.grid[r][c], {
                        fontFamily: 'Arial Black',
                        fontSize: `${Math.floor(this.cellSize*0.45)}px`,
                        color: '#ffffff',
                        stroke: '#000000',
                        strokeThickness: Math.floor(4*this.uiScale)
                    }).setOrigin(0.5);

                    if(!isStartingCell) {
                        cell.on('pointerdown', () => this.selectCell(r, c));
                    }

                    this.cells[r][c] = cell;
                    this.cellTexts[r][c] = text;
                }
            }

            if(this.selectedCell) {
                const [r,c] = this.selectedCell;
                this.cells[r][c].setStrokeStyle(5*this.uiScale, 0xfeca57);
            }
        }

        selectCell(row, col) {
            if(this.startingCell && this.startingCell[0]===row && this.startingCell[1]===col) {
                return;
            }

            if(this.selectedCell) {
                const [r,c] = this.selectedCell;
                if(!this.startingCell || this.startingCell[0]!==r || this.startingCell[1]!==c) {
                    this.cells[r][c].setStrokeStyle(3*this.uiScale, 0x1a1a2e);
                }
            }

            this.selectedCell = [row, col];
            this.cells[row][col].setStrokeStyle(5*this.uiScale, 0xfeca57);

            this.tweens.add({
                targets: this.cells[row][col],
                scale: 1.08,
                duration: 80,
                yoyo: true
            });
        }

        createKeyboard() {
            const {width, height} = this.cameras.main;
            const startY = this.startY + this.gridSize*this.cellSize + height*0.03;

            const maxKeyboardWidth = width * 0.95;
            const keySize = Math.floor(Math.min(this.cellSize*0.6, maxKeyboardWidth/11));
            const spacing = keySize * 1.1;

            const rows = [10, 9, 7];
            const letters = 'QWERTYUIOPASDFGHJKLZXCVBNM'.split('');

            let index = 0;

            rows.forEach((count, row) => {
                const rowWidth = count * spacing;
                const startX = (width - rowWidth)/2;

                for(let i = 0; i < count && index < letters.length; i++) {
                    const x = startX + i*spacing + spacing/2;
                    const y = startY + row*spacing*0.95;

                    this.add.rectangle(x+2*this.uiScale, y+2*this.uiScale, keySize, keySize, 0x000000, 0.3);

                    const key = this.add.rectangle(x, y, keySize, keySize, 
                        COLORS[index % COLORS.length]).setInteractive();
                    key.setStrokeStyle(2*this.uiScale, 0x1a1a2e);

                    const letter = letters[index];

                    this.add.text(x, y, letter, {
                        fontFamily: 'Arial Black',
                        fontSize: `${Math.floor(keySize*0.5)}px`,
                        color: '#ffffff',
                        stroke: '#000000',
                        strokeThickness: Math.floor(3*this.uiScale)
                    }).setOrigin(0.5);

                    key.on('pointerdown', () => {
                        this.typeLetter(letter);
                        this.tweens.add({targets: key, y: y+2, duration: 50, yoyo: true});
                    });

                    index++;
                }
            });

            const delY = startY + 3*spacing*0.95;
            const delWidth = keySize * 2.5;
            const delX = width/2;

            this.add.rectangle(delX+3*this.uiScale, delY+3*this.uiScale, delWidth, keySize, 0x000000, 0.3);

            const delKey = this.add.rectangle(delX, delY, delWidth, keySize, 0xff6b6b).setInteractive();
            delKey.setStrokeStyle(3*this.uiScale, 0xee5a6f);

            this.add.text(delX, delY, 'DELETE', {
                fontFamily: 'Arial Black',
                fontSize: `${Math.floor(keySize*0.45)}px`,
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: Math.floor(3*this.uiScale)
            }).setOrigin(0.5);

            delKey.on('pointerdown', () => {
                this.deleteLetter();
                this.tweens.add({targets: delKey, y: delY+2, duration: 50, yoyo: true});
            });
        }

        typeLetter(letter) {
            if(!this.selectedCell) {
                outer: for(let r = 0; r < this.gridSize; r++) {
                    for(let c = 0; c < this.gridSize; c++) {
                        const isStarting = this.startingCell && this.startingCell[0]===r && this.startingCell[1]===c;
                        if(!this.grid[r][c] && !isStarting) {
                            this.selectCell(r, c);
                            break outer;
                        }
                    }
                }
            }

            if(!this.selectedCell) return;

            const [r,c] = this.selectedCell;

            if(this.startingCell && this.startingCell[0]===r && this.startingCell[1]===c) {
                return;
            }

            this.grid[r][c] = letter;
            this.cellTexts[r][c].setText(letter);
            this.cells[r][c].setFillStyle(this.cellColors[r][c]);

            this.tweens.add({
                targets: this.cellTexts[r][c],
                scale: 1.3,
                duration: 100,
                yoyo: true
            });
        }

        deleteLetter() {
            if(!this.selectedCell) return;

            const [r,c] = this.selectedCell;

            if(this.startingCell && this.startingCell[0]===r && this.startingCell[1]===c) {
                this.showMessage('Cannot delete starting letter!', 0xff6b6b);
                return;
            }

            this.grid[r][c] = '';
            this.cellTexts[r][c].setText('');
            this.cells[r][c].setFillStyle(0x2d3561);
        }

        createBackButton() {
            const size = 48*this.uiScale;
            const x = size;
            const y = size;

            this.add.rectangle(x+2, y+2, size*2, size, 0x000000, 0.3);

            const btn = this.add.rectangle(x, y, size*2, size, 0x5f27cd).setInteractive();
            btn.setStrokeStyle(3*this.uiScale, 0x341f97);

            const buttonText = this.isDailyMode ? 'BACK' : 'RESET';
            this.add.text(x, y, buttonText, {
                fontFamily: 'Arial Black',
                fontSize: `${Math.floor(16*this.uiScale)}px`,
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: Math.floor(3*this.uiScale)
            }).setOrigin(0.5);

            btn.on('pointerdown', () => {
                this.cameras.main.flash(200);
                if(this.isDailyMode) {
                    this.time.delayedCall(200, () => this.scene.start('DailyChallengeMenu'));
                } else {
                    this.time.delayedCall(200, () => this.scene.restart({
                        gridSize: this.gridSize, 
                        isFreeMode: this.isFreeMode
                    }));
                }
            });
        }

        createMenuButton() {
            const {width} = this.cameras.main;
            const size = 48*this.uiScale;
            const x = width - size;
            const y = size;

            this.add.rectangle(x+2, y+2, size*2, size, 0x000000, 0.3);

            const btn = this.add.rectangle(x, y, size*2, size, 0xF97F51).setInteractive();
            btn.setStrokeStyle(3*this.uiScale, 0xC44569);

            this.add.text(x, y, 'MENU', {
                fontFamily: 'Arial Black',
                fontSize: `${Math.floor(16*this.uiScale)}px`,
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: Math.floor(3*this.uiScale)
            }).setOrigin(0.5);

            btn.on('pointerdown', () => {
                this.cameras.main.flash(200);
                this.time.delayedCall(200, () => this.scene.start('MainMenu'));
            });
        }

        createCheckButton() {
            const {width, height} = this.cameras.main;
            
            // Position check button above keyboard (keyboard starts at height - 90 - 70)
            const keyboardStartY = height - 90 - 70;
            
            const buttonWidth = width * 0.7;
            const buttonHeight = 55 * this.uiScale;
            const gap = 15 * this.uiScale;
            const buttonY = keyboardStartY - gap - buttonHeight / 2;

            this.add.rectangle(width / 2 + 3, buttonY + 3, buttonWidth, buttonHeight, 0x000000, 0.3);

            const btn = this.add.rectangle(width / 2, buttonY, buttonWidth, buttonHeight, 0x1dd1a1).setInteractive();
            btn.setStrokeStyle(4 * this.uiScale, 0x10ac84);

            this.add.text(width / 2, buttonY, 'CHECK SOLUTION âœ“', {
                fontFamily: 'Arial Black',
                fontSize: `${Math.floor(20 * this.uiScale)}px`,
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: Math.floor(4 * this.uiScale)
            }).setOrigin(0.5);

            btn.on('pointerdown', () => {
                this.checkSolution();
                this.tweens.add({targets: btn, y: buttonY + 3, duration: 50, yoyo: true});
            });

            // Hover effect
            btn.on('pointerover', () => {
                this.tweens.add({targets: btn, scaleX: 1.02, scaleY: 1.02, duration: 100});
            });

            btn.on('pointerout', () => {
                this.tweens.add({targets: btn, scaleX: 1, scaleY: 1, duration: 100});
            });
        }

        checkSolution() {
    let hasEmpty = false;
    const invalidWords = [];

    // Check for empty cells
    for(let r = 0; r < this.gridSize; r++) {
        for(let c = 0; c < this.gridSize; c++) {
            if(!this.grid[r][c]) hasEmpty = true;
        }
    }

    if(hasEmpty) {
        this.showMessage('Fill all cells!', 0xff6b6b);
        return [];
    }

    // Check rows for invalid words
    for(let r = 0; r < this.gridSize; r++) {
        const word = this.grid[r].join('').toLowerCase();
        if(!VALID_WORDS.has(word)) {
            invalidWords.push(word);
        }
    }

    // Check columns for invalid words
    for(let c = 0; c < this.gridSize; c++) {
        const word = this.grid.map(r => r[c]).join('').toLowerCase();
        if(!VALID_WORDS.has(word)) {
            invalidWords.push(word);
        }
    }

    // If no invalid words, user wins
    if(invalidWords.length === 0) {
        if(this.isDailyMode) {
            markDailyChallengeCompleted(this.todayDate, this.gridSize);
        }
        this.showVictory();
        return [];
    }

    // Otherwise, show invalid words message and return them
    this.showMessage(`Invalid words: ${invalidWords.join('\n')}`, 0xff6b6b);
    return invalidWords;
}

        showMessage(msg, color) {
            const {width, height} = this.cameras.main;
            
            // Create semi-transparent overlay
            const overlay = this.add.rectangle(width / 2, height / 2, width, height, 0x000000, 0.7);
            
            // Create message background - make it taller for multiple lines
            const msgWidth = width * 0.85;
            const msgHeight = Math.max(150 * this.uiScale, 200 * this.uiScale);
            
            const msgBg = this.add.rectangle(width / 2, height / 2, msgWidth, msgHeight, color);
            msgBg.setStrokeStyle(4 * this.uiScale, 0x000000);
            
            const text = this.add.text(width / 2, height / 2, msg, {
                fontFamily: 'Arial Black',
                fontSize: `${Math.floor(36 * this.uiScale)}px`,
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: Math.floor(4 * this.uiScale),
                align: 'center',
                wordWrap: { width: msgWidth - 40 }
            }).setOrigin(0.5);

            // Fade out animation
            this.tweens.add({
                targets: [overlay, msgBg, text],
                alpha: 0,
                duration: 2000,
                delay: 2000,
                onComplete: () => {
                    overlay.destroy();
                    msgBg.destroy();
                    text.destroy();
                }
            });
        }

        showVictory() {
            const {width, height} = this.cameras.main;

            for(let i = 0; i < 30; i++) {
                const x = Phaser.Math.Between(0, width);
                const y = Phaser.Math.Between(0, height);
                const star = this.add.text(x, y, 'â­', {fontSize: `${Math.floor(30*this.uiScale)}px`});

                this.tweens.add({
                    targets: star,
                    scale: 2,
                    alpha: 0,
                    angle: 360,
                    duration: 1500,
                    onComplete: () => star.destroy()
                });
            }

            this.add.rectangle(width/2, height/2, width, height, 0x000000, 0.7);

            const text = this.add.text(width/2, height/2 - 60*this.uiScale, 'ðŸŽ‰ COMPLETE! ðŸŽ‰', {
                fontFamily: 'Arial Black',
                fontSize: `${Math.floor(52*this.uiScale)}px`,
                color: '#feca57',
                stroke: '#000000',
                strokeThickness: Math.floor(8*this.uiScale)
            }).setOrigin(0.5);

            this.tweens.add({
                targets: text,
                scale: 1.2,
                yoyo: true,
                repeat: -1,
                duration: 500
            });

            // Share button
            const shareBtn = this.add.rectangle(width/2, height/2 + 60*this.uiScale, 220*this.uiScale, 60*this.uiScale, 0x48DBFB);
            shareBtn.setStrokeStyle(4*this.uiScale, 0x0ABDE3);
            shareBtn.setInteractive();

            const shareText = this.add.text(width/2, height/2 + 60*this.uiScale, 'ðŸ“¤ SHARE', {
                fontFamily: 'Arial Black',
                fontSize: `${Math.floor(24*this.uiScale)}px`,
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: Math.floor(4*this.uiScale)
            }).setOrigin(0.5);

            shareBtn.on('pointerdown', () => {
                this.tweens.add({targets: shareBtn, scaleX: 0.95, scaleY: 0.95, duration: 100, yoyo: true});
                this.shareGrid();
            });
        }

        shareGrid() {
            const vowels = new Set(['A', 'E', 'I', 'O', 'U']);
            let shareText = `Grid Complete ${this.gridSize}x${this.gridSize}\n\n`;

            for(let r = 0; r < this.gridSize; r++) {
                for(let c = 0; c < this.gridSize; c++) {
                    const letter = this.grid[r][c];
                    
                    // Show starting letter
                    if(this.startingCell && this.startingCell[0] === r && this.startingCell[1] === c) {
                        shareText += letter + ' ';
                    }
                    // Blue square for vowels
                    else if(vowels.has(letter)) {
                        shareText += 'ðŸŸ¦';
                    }
                    // Red square for consonants
                    else {
                        shareText += 'ðŸŸ¥';
                    }
                }
                shareText += '\n';
            }

            shareText += '\nCan you solve it? Play Grid Complete!';

            // Try to use native share API if available
            if(navigator.share) {
                navigator.share({
                    title: 'Grid Complete',
                    text: shareText
                }).catch(err => {
                    console.log('Share cancelled or failed:', err);
                    this.copyToClipboard(shareText);
                });
            } else {
                // Fallback to clipboard
                this.copyToClipboard(shareText);
            }
        }

        copyToClipboard(text) {
            if(navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    this.showMessage('Copied to clipboard! ðŸ“‹', 0x1dd1a1);
                }).catch(() => {
                    this.fallbackCopy(text);
                });
            } else {
                this.fallbackCopy(text);
            }
        }

        fallbackCopy(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            document.body.appendChild(textArea);
            textArea.select();
            
            try {
                document.execCommand('copy');
                this.showMessage('Copied to clipboard! ðŸ“‹', 0x1dd1a1);
            } catch(err) {
                this.showMessage('Could not copy. Please share manually.', 0xff6b6b);
            }
            
            document.body.removeChild(textArea);
        }
    }

 class UnscrambleModeScene extends Phaser.Scene {
  private sizeOptions = [3, 4, 5, 6]
  private gridSize = 5 // default
  private originalGrid: string[][] = []
  private scrambledGrid: string[][] = []
  private cellRects: Phaser.GameObjects.Rectangle[][] = []
  private cellTexts: Phaser.GameObjects.Text[][] = []

  constructor() {
    super('UnscrambleModeScene')
  }

  preload() {}

  create() {
    this.add.text(100, 40, 'Unscramble Mode', {
      fontFamily: 'Arial Black',
      color: '#ffffff',
      fontSize: '40px'
    })

    this.createSizeSelection()
  }

  // ------------------------------------------------
  // BOARD SIZE SELECTION
  // ------------------------------------------------
  private createSizeSelection() {
    this.add.text(100, 120, 'Select Grid Size:', {
      fontFamily: 'Arial Black',
      color: '#ffff00',
      fontSize: '24px'
    })

    this.sizeOptions.forEach((s, index) => {
      const txt = this.add.text(100, 170 + index * 40, `${s} x ${s}`, {
        fontFamily: 'Arial Black',
        color: '#00ffea',
        fontSize: '24px'
      })
      txt.setInteractive()
      txt.on('pointerdown', () => {
        this.gridSize = s
        this.startGame()
      })
    })
  }

  // ------------------------------------------------
  // START MODE
  // ------------------------------------------------
  private startGame() {
    this.originalGrid = this.generateValidGrid()
    this.scrambledGrid = this.scrambleGrid(this.originalGrid)

    this.drawGrid()
    this.enableDragging()

    this.createCheckButton()
    this.createBackButton()
  }

  // ------------------------------------------------
  // GRID GENERATION
  // ------------------------------------------------
  private generateValidGrid(): string[][] {
    const grid: string[][] = []
    for (let r = 0; r < this.gridSize; r++) {
      const row: string[] = []
      for (let c = 0; c < this.gridSize; c++) {
        const rand = words[Math.floor(Math.random() * words.length)]
        row.push(rand[Math.floor(Math.random() * rand.length)].toUpperCase())
      }
      grid.push(row)
    }
    return grid
  }

  private scrambleGrid(grid: string[][]): string[][] {
    const letters = grid.flat()
    for (let i = letters.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1))
      ;[letters[i], letters[j]] = [letters[j], letters[i]]
    }

    const out: string[][] = []
    let index = 0
    for (let r = 0; r < this.gridSize; r++) {
      out.push(letters.slice(index, index + this.gridSize))
      index += this.gridSize
    }
    return out
  }

  // ------------------------------------------------
  // DRAW BOARD
  // ------------------------------------------------
  private drawGrid() {
    const startX = 200
    const startY = 200
    const size = 70

    this.cellRects = []
    this.cellTexts = []

    for (let r = 0; r < this.gridSize; r++) {
      const rowRects = []
      const rowTexts = []

      for (let c = 0; c < this.gridSize; c++) {
        const x = startX + c * size
        const y = startY + r * size

        const rect = this.add.rectangle(x, y, size - 4, size - 4, 0x202020)
          .setStrokeStyle(2, 0xffffff)
          .setOrigin(0)

        const letter = this.scrambledGrid[r][c]
        const text = this.add.text(x + 20, y + 15, letter, {
          fontFamily: 'Arial Black',
          color: '#ffffff',
          fontSize: '32px'
        })

        text.setData('row', r)
        text.setData('col', c)
        text.setInteractive({ draggable: true })

        rowRects.push(rect)
        rowTexts.push(text)
      }
      this.cellRects.push(rowRects)
      this.cellTexts.push(rowTexts)
    }
  }

  // ------------------------------------------------
  // DRAGGING + SNAP
  // ------------------------------------------------
  private enableDragging() {
    this.input.on('drag', (_pointer, obj: Phaser.GameObjects.Text, x, y) => {
      obj.x = x
      obj.y = y
    })

    this.input.on('dragend', (_pointer, obj: Phaser.GameObjects.Text) => {
      const size = 70
      const startX = 200
      const startY = 200

      let snapped = false

      for (let r = 0; r < this.gridSize; r++) {
        for (let c = 0; c < this.gridSize; c++) {
          const cellX = startX + c * size
          const cellY = startY + r * size

          const bounds = new Phaser.Geom.Rectangle(cellX, cellY, size, size)
          if (bounds.contains(obj.x, obj.y)) {
            const target = this.cellTexts[r][c]
            const oldR = obj.getData('row')
            const oldC = obj.getData('col')

            // Swap letters
            const temp = target.text
            target.text = obj.text
            obj.text = temp

            // reset to proper positions
            this.positionText(target, r, c)
            this.positionText(obj, oldR, oldC)

            // update metadata
            target.setData('row', oldR)
            target.setData('col', oldC)
            obj.setData('row', r)
            obj.setData('col', c)

            snapped = true
          }
        }
      }

      if (!snapped) {
        const r = obj.getData('row')
        const c = obj.getData('col')
        this.positionText(obj, r, c)
      }
    })
  }

  private positionText(obj: Phaser.GameObjects.Text, r: number, c: number) {
    const size = 70
    const startX = 200
    const startY = 200
    obj.x = startX + c * size + 20
    obj.y = startY + r * size + 15
  }

  // ------------------------------------------------
  // CHECK SOLUTION
  // ------------------------------------------------
  private createCheckButton() {
    const btn = this.add.text(200, 200 + this.gridSize * 80, 'CHECK', {
      fontFamily: 'Arial Black',
      color: '#00ff00',
      fontSize: '32px'
    })
      .setInteractive()

    btn.on('pointerdown', () => {
      const userGrid = this.getUserGrid()
      const isOriginal = JSON.stringify(userGrid) === JSON.stringify(this.originalGrid)
      const anotherValid = this.isValidGrid(userGrid)

      if (isOriginal) {
        alert('Correct! You matched the solution!')
      } else if (anotherValid) {
        alert('Amazing! You found an alternate valid solution!')
      } else {
        alert('Not valid. Keep trying!')
      }
    })
  }

  private getUserGrid(): string[][] {
    return this.cellTexts.map(row => row.map(t => t.text))
  }

  private isValidGrid(grid: string[][]): boolean {
    // Check rows
    for (let r = 0; r < this.gridSize; r++) {
      const word = grid[r].join('')
      if (!words.includes(word.toLowerCase())) return false
    }
    // Check columns
    for (let c = 0; c < this.gridSize; c++) {
      const col = grid.map(r => r[c]).join('')
      if (!words.includes(col.toLowerCase())) return false
    }
    return true
  }

  // ------------------------------------------------
  // BACK BUTTON
  // ------------------------------------------------
  private createBackButton() {
    const btn = this.add.text(50, 50, '< BACK', {
      fontFamily: 'Arial Black',
      color: '#ff4444',
      fontSize: '28px'
    })
      .setInteractive()

    btn.on('pointerdown', () => {
      this.scene.start('MainMenuScene')
    })
  }
}

    class MainMenuScene extends Phaser.Scene {
        constructor() {
            super('MainMenu');
        }

        create() {
            const {width, height} = this.cameras.main;
            const minDim = Math.min(width, height);
            const uiScale = minDim / 750;

            drawBricks(this, width, height);

            // Title
            const title = this.add.text(width/2, height*0.25, 'GRID\nCOMPLETE', {
                fontSize: `${Math.floor(72*uiScale)}px`,
                fontFamily: 'Arial Black',
                color: '#ffffff',
                align: 'center',
                stroke: '#2d3561',
                strokeThickness: Math.floor(10*uiScale)
            });
            title.setOrigin(0.5);
            title.setShadow(5, 5, '#000000', 10);

            this.tweens.add({
                targets: title,
                y: height*0.25 - 10,
                duration: 1000,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });

            // Classic Mode Button
            this.createButton(width/2, height*0.45, 'CLASSIC\nMODE', 0xFF6B6B, 0xEE5A6F, () => {
                this.scene.start('ClassicMode', {gridSize: 5, isDailyMode: false, isFreeMode: false});
            });

            // Free Mode Button
            this.createButton(width/2, height*0.6, 'FREE\nMODE', 0x1DD1A1, 0x10ac84, () => {
                this.scene.start('ClassicMode', {gridSize: 5, isDailyMode: false, isFreeMode: true});
            });

            // Daily Challenge Button
            this.createButton(width/2, height*0.75, 'DAILY\nCHALLENGE', 0xFECA57, 0xF97F51, () => {
                this.scene.start('DailyChallengeMenu');
            });
            
            // Unscramble mode
            this.createButton(width/2, height*0.75, 'UNSCRAMBLE\nCHALLENGE', 0xFECA57, 0xF97F51, () => {
                this.scene.start('UnscrambleMode');
            });
        }

        createButton(x, y, text, color1, color2, callback) {
            const container = this.add.container(x, y);

            const shadow = this.add.rectangle(8, 8, 280, 100, 0x000000, 0.3).setOrigin(0.5);
            const bottom = this.add.rectangle(4, 4, 280, 100, color2).setOrigin(0.5);
            const top = this.add.rectangle(0, 0, 280, 100, color1).setOrigin(0.5);

            const buttonText = this.add.text(0, 0, text, {
                fontSize: '32px',
                fontFamily: 'Arial Black',
                color: '#ffffff',
                align: 'center',
                stroke: '#000000',
                strokeThickness: 6
            }).setOrigin(0.5);

            container.add([shadow, bottom, top, buttonText]);
            container.setSize(280, 100);
            container.setInteractive();

            container.on('pointerover', () => {
                this.tweens.add({targets: container, scale: 1.05, duration: 100});
            });

            container.on('pointerout', () => {
                this.tweens.add({targets: container, scale: 1, duration: 100});
            });

            container.on('pointerdown', () => {
                this.tweens.add({targets: [top, buttonText], y: 4, duration: 50});
                this.cameras.main.flash(200);
                this.time.delayedCall(200, callback);
            });

            container.on('pointerup', () => {
                this.tweens.add({targets: [top, buttonText], y: 0, duration: 50});
            });
        }
    }

    class DailyChallengeMenuScene extends Phaser.Scene {
        constructor() {
            super('DailyChallengeMenu');
        }

        create() {
            const {width, height} = this.cameras.main;
            const minDim = Math.min(width, height);
            const uiScale = minDim / 750;
            const todayDate = getTodayDate();

            drawBricks(this, width, height);

            // Title
            this.add.rectangle(width/2, height*0.12, width, height*0.12, 0x2d3561);
            this.add.text(width/2, height*0.06, 'DAILY CHALLENGE', {
                fontFamily: 'Arial Black',
                fontSize: `${Math.floor(32*uiScale)}px`,
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: Math.floor(6*uiScale)
            }).setOrigin(0.5);

            this.add.text(width/2, height*0.10, todayDate, {
                fontFamily: 'Arial',
                fontSize: `${Math.floor(18*uiScale)}px`,
                color: '#feca57'
            }).setOrigin(0.5);

            // Grid size buttons
            const sizes = [3, 4, 5, 6];
            const startY = height * 0.25;
            const spacing = height * 0.15;

            sizes.forEach((size, i) => {
                const y = startY + i * spacing;
                const isCompleted = isDailyChallengeCompleted(todayDate, size);
                const challengeData = getDailyChallengeData(todayDate, size);

                this.createChallengeButton(width/2, y, size, isCompleted, challengeData, uiScale);
            });

            // Back button
            this.createBackButton(48*uiScale, 48*uiScale, uiScale);
        }

        createChallengeButton(x, y, size, isCompleted, challengeData, uiScale) {
            const container = this.add.container(x, y);

            const bgColor = isCompleted ? 0x1dd1a1 : (challengeData ? 0x48DBFB : 0x64748b);
            const borderColor = isCompleted ? 0x10ac84 : (challengeData ? 0x0ABDE3 : 0x475569);

            const shadow = this.add.rectangle(6, 6, 320, 80, 0x000000, 0.3).setOrigin(0.5);
            const bg = this.add.rectangle(0, 0, 320, 80, bgColor).setOrigin(0.5);
            bg.setStrokeStyle(4*uiScale, borderColor);

            const text = this.add.text(-100, 0, `${size}x${size} GRID`, {
                fontFamily: 'Arial Black',
                fontSize: `${Math.floor(24*uiScale)}px`,
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: Math.floor(4*uiScale)
            }).setOrigin(0, 0.5);

            const statusText = isCompleted ? 'âœ“ COMPLETED' : (challengeData ? 'PLAY' : 'COMING SOON');
            const status = this.add.text(100, 0, statusText, {
                fontFamily: 'Arial Black',
                fontSize: `${Math.floor(16*uiScale)}px`,
                color: isCompleted ? '#ffffff' : (challengeData ? '#ffffff' : '#999999'),
                stroke: '#000000',
                strokeThickness: Math.floor(3*uiScale)
            }).setOrigin(1, 0.5);

            container.add([shadow, bg, text, status]);
            container.setSize(320, 80);

            if(!isCompleted && challengeData) {
                container.setInteractive();

                container.on('pointerdown', () => {
                    this.cameras.main.flash(200);
                    this.time.delayedCall(200, () => {
                        this.scene.start('ClassicMode', {gridSize: size, isDailyMode: true});
                    });
                });

                container.on('pointerover', () => {
                    this.tweens.add({targets: container, scale: 1.05, duration: 100});
                });

                container.on('pointerout', () => {
                    this.tweens.add({targets: container, scale: 1, duration: 100});
                });
            }
        }

        createBackButton(x, y, uiScale) {
            this.add.rectangle(x+2, y+2, 90, 50, 0x000000, 0.3);
            const btn = this.add.rectangle(x, y, 90, 50, 0x5f27cd).setInteractive();
            btn.setStrokeStyle(3*uiScale, 0x341f97);

            this.add.text(x, y, 'BACK', {
                fontFamily: 'Arial Black',
                fontSize: `${Math.floor(18*uiScale)}px`,
                color: '#ffffff',
                stroke: '#000000',
                strokeThickness: Math.floor(3*uiScale)
            }).setOrigin(0.5);

            btn.on('pointerdown', () => {
                this.cameras.main.flash(200);
                this.time.delayedCall(200, () => this.scene.start('MainMenu'));
            });
        }
    }

    const config = {
        type: Phaser.AUTO,
        width: Math.min(600, window.innerWidth),
        height: Math.min(1920, window.innerHeight),
        parent: 'game-container',
        backgroundColor: '#1a1a2e',
        scene: [MainMenuScene, DailyChallengeMenuScene, ClassicModeScene, UnscrambleModeScene],
        scale: {
            mode: Phaser.Scale.FIT,
            autoCenter: Phaser.Scale.CENTER_BOTH
        }
    };

    new Phaser.Game(config);
</script>

</body>
</html>