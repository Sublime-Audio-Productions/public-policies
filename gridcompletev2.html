<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Complete - Classic Mode</title>
    <script>
window.onerror = function(message, source, lineno, colno, error) {
    alert(`Error: ${message}\nFile: ${source}\nLine: ${lineno}:${colno}`);
};

const originalError = console.error;
console.error = function(...args) {
    alert(args.join("\n"));
    originalError.apply(console, args);
};
</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #1a1a2e; }
        #game-container { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script>
        let VALID_WORDS = new Set();
        const COLORS = [0xFF6B6B,0xFECA57,0x48DBFB,0x1DD1A1,0xEE5A6F,0xC44569,0xF97F51,0x5F27CD,0x00D2D3,0x54A0FF];
        let WORDS_LOADED = false;
        let GRID_POOLS = null;
        let DAILY_CHALLENGES_DATA = null;

        // In-memory storage for daily challenge completions (replaces localStorage)
        const dailyCompletions = new Map();
        
        // Statistics storage
        const gameStats = {
            gamesPlayed: 0,
            gamesWon: 0,
            totalTime: 0,
            bestTime: Infinity,
            currentStreak: 0,
            maxStreak: 0,
            gridSizeStats: {
                3: { played: 0, won: 0 },
                4: { played: 0, won: 0 },
                5: { played: 0, won: 0 },
                6: { played: 0, won: 0 }
            }
        };

        async function loadWords() {
            try {
                const urls = [
                    'https://raw.githubusercontent.com/jonathanwelton/word-lists/main/3-letter-words.json',
                    'https://raw.githubusercontent.com/jonathanwelton/word-lists/main/4-letter-words.json',
                    'https://raw.githubusercontent.com/jonathanwelton/word-lists/main/5-letter-words.json',
                ];

                const responses = await Promise.all(urls.map(url => 
                    fetch(url).catch(err => {
                        console.warn(`Failed to fetch ${url}:`, err);
                        return null;
                    })
                ));

                const dataArrays = await Promise.all(responses.map(async (res, idx) => {
                    if (!res || !res.ok) {
                        console.warn(`Skipping failed response for URL ${idx}`);
                        return [];
                    }
                    try {
                        return await res.json();
                    } catch (e) {
                        console.warn(`Failed to parse JSON from URL ${idx}:`, e);
                        return [];
                    }
                }));

                const allWords = dataArrays.flat();
                
                if (allWords.length > 0) {
                    VALID_WORDS = new Set(allWords);
                    WORDS_LOADED = true;
                    console.log(`Loaded ${VALID_WORDS.size} words from online sources`);
                    return;
                }
                
                throw new Error('No words loaded from online sources');
            } catch (error) {
                console.warn('Failed to load words from online sources, using fallback dictionary:', error);
                useFallbackWords();
            }
        }

        function useFallbackWords() {
            // Comprehensive fallback word list
            const fallbackWords = [
                // 3-letter words
                'ace','act','add','age','ago','aid','aim','air','all','and','ant','any','ape','arc','are','ark','arm','art','ask','ate','awe','axe','aye',
                'bad','bag','ban','bar','bat','bay','bed','bee','bet','bid','big','bin','bit','boa','bog','bow','box','boy','bud','bug','bun','bus','but','buy',
                'cab','can','cap','car','cat','cob','cod','cog','cop','cot','cow','cox','coy','cry','cub','cud','cue','cup','cur','cut',
                'dab','dad','dam','day','den','dew','did','die','dig','dim','din','dip','doc','doe','dog','don','dot','dry','dub','dud','due','dug','dye',
                'ear','eat','ebb','eel','egg','ego','elf','elk','elm','emu','end','era','err','eve','ewe','eye',
                'fad','fan','far','fat','fax','fed','fee','fen','few','fib','fig','fin','fir','fit','fix','fly','fob','foe','fog','for','fox','fry','fun','fur',
                'gab','gag','gap','gas','gay','gel','gem','get','gig','gin','gnu','gob','god','got','gum','gun','gut','guy','gym',
                'had','hag','ham','has','hat','hay','hem','hen','her','hew','hex','hey','hid','him','hip','his','hit','hob','hod','hoe','hog','hop','hot','how','hub','hue','hug','hum','hut',
                'ice','icy','ill','imp','ink','inn','ion','ire','irk','its','ivy',
                'jab','jam','jar','jaw','jay','jet','jig','job','jog','jot','joy','jug',
                'keg','ken','key','kid','kin','kit',
                'lab','lac','lad','lag','lap','law','lax','lay','lea','led','leg','let','lid','lie','lip','lit','log','lot','low','lug',
                'mad','man','map','mar','mat','maw','max','may','men','met','mid','mix','mob','mod','mom','mop','mow','mud','mug','mum',
                'nab','nag','nap','nay','net','new','nib','nit','nod','nor','not','now','nun','nut',
                'oak','oar','oat','odd','ode','off','oft','oil','old','one','opt','orb','ore','our','out','owe','owl','own',
                'pac','pad','pal','pan','pap','par','pat','paw','pax','pay','pea','peg','pen','pep','per','pet','pew','pie','pig','pin','pit','ply','pod','pop','pot','pox','pry','pub','pug','pun','pup','pus','put',
                'rag','ram','ran','rap','rat','raw','ray','red','ref','rib','rid','rig','rim','rip','rob','rod','roe','rot','row','rub','rug','rum','run','rut','rye',
                'sac','sad','sag','sap','sat','saw','sax','say','sea','see','set','sew','sex','she','shy','sin','sip','sir','sis','sit','six','ska','ski','sky','sly','sob','sod','son','sop','sot','sow','sox','soy','spa','spy','sty','sub','sue','sum','sun','sup',
                'tab','tad','tag','tan','tap','tar','tat','tax','tea','ten','the','thy','tic','tie','tin','tip','toe','tog','ton','too','top','tot','tow','toy','try','tub','tug','two',
                'ugh','urn','use',
                'van','vat','vet','vex','via','vie','vow',
                'wad','wag','wan','war','was','wax','way','web','wed','wee','wet','who','why','wig','win','wit','woe','wok','won','woo','wow',
                'yak','yam','yap','yaw','yay','yea','yes','yet','yew','yin','yip','you','yow',
                'zap','zen','zip','zit','zoo',
                
                // 4-letter words
                'able','ache','acid','acme','acre','acts','adds','afar','ages','aims','airs','airy','ajar','akin','ales','alive','alls','ally','alms','aloe','alps','also','amid','amps','ankh','anew','ante','ants','apes','apex','arch','arcs','area','ares','args','aria','arid','arms','army','arts','ashy','asks','atom','atop','aunt','aura','auto','avid','awed','awes','awls','awry','axes','axis','axle','ayes',
                'baby','back','bade','bags','bail','bait','bake','bald','bale','ball','balm','band','bane','bang','bank','bans','barb','bard','bare','bark','barn','bars','base','bash','bask','bass','bath','bats','bays','bead','beak','beam','bean','bear','beat','beds','beef','been','beep','beer','bees','beet','bell','belt','bend','bent','berg','best','beta','bets','bias','bibs','bids','bike','bile','bill','bind','bins','bird','bite','bits','bled','blew','blob','bloc','blog','blot','blow','blue','blur','boar','boat','bobs','bode','body','bogs','boil','bold','bolt','bomb','bond','bone','bony','book','boom','boon','boor','boot','bore','born','boss','both','bout','bowl','bows','boys','brad','brag','bran','bras','brat','brew','brim','brow','buck','buds','buff','bugs','bulb','bulk','bull','bump','bums','bunk','buns','buoy','burp','bury','bush','busk','buss','bust','busy','butt','buys','buzz',
                'cabs','cafe','cage','cake','calf','call','calm','came','camp','cane','cans','cape','caps','card','care','carp','cars','cart','case','cash','cask','cast','cats','cave','cede','cell','cent','chap','char','chat','chef','chew','chin','chip','chop','chug','chum','cite','city','clad','clam','clap','claw','clay','clef','clip','clod','clog','clot','club','clue','coal','coat','cobs','cock','coda','code','cods','cogs','coil','coin','cold','cole','cols','colt','coma','comb','come','cone','conk','cook','cool','coop','cope','cops','copy','cord','core','cork','corn','cost','cosy','cots','coup','cove','cows','cozy','crab','cram','crib','crop','crow','cube','cubs','cued','cues','cuff','cult','cups','curb','curd','cure','curl','curt','cusp','cuts','cyan',
                'dabs','dads','daft','dame','damn','damp','dams','dank','dare','dark','darn','dart','dash','data','date','daub','dawn','days','daze','dead','deaf','deal','dean','dear','debt','deck','deed','deem','deep','deer','deft','defy','deli','dell','demo','dens','dent','deny','desk','dews','dial','dice','died','dies','diet','digs','dill','dime','dims','dine','ding','dink','dins','dint','dips','dire','dirk','dirt','disc','dish','disk','diva','dive','dock','docs','dodo','doer','does','doge','dogs','dojo','dole','doll','dolt','dome','done','doom','door','dope','dorm','dose','dote','doth','dots','dour','dove','down','doze','dozy','drab','drag','dram','drat','draw','dray','drew','drip','drop','drug','drum','dual','dubs','duck','duct','dude','duds','duel','dues','duet','duke','dull','duly','dumb','dump','dune','dung','dunk','dupe','dusk','dust','duty','dyes',
                'each','earl','earn','ears','ease','east','easy','eats','ebbs','echo','eddy','edge','edgy','edit','eels','eggs','egos','eked','ekes','elks','elms','else','emus','ends','envy','eons','epic','eras','ergo','errs','euro','even','ever','eves','evil','ewer','ewes','exam','exec','exit','expo','eyed','eyes',
                'face','fact','fade','fads','fail','fain','fair','fake','fall','fame','fang','fans','fare','farm','faro','fast','fate','fats','fawn','faze','fear','feat','feed','feel','fees','feet','fell','felt','fend','fens','fern','fest','feud','fiat','fibs','fief','fife','figs','file','fill','film','find','fine','fink','fins','fire','firm','firs','fish','fist','fits','five','fizz','flab','flag','flak','flan','flap','flat','flaw','flax','flay','flea','fled','flee','flew','flex','flip','flit','floe','flog','flop','flow','flub','flue','flux','foal','foam','fobs','foci','foes','fogs','fogy','foil','fold','folk','fond','font','food','fool','foot','ford','fore','fork','form','fort','foul','four','fowl','foxy','fray','free','fret','frog','from','fuel','full','fume','fund','funk','furl','furs','fury','fuse','fuss','fuzz',
                'gabs','gags','gain','gait','gala','gale','gall','game','gang','gaps','garb','gash','gasp','gate','gave','gawk','gays','gaze','gear','geek','gees','gels','gems','gene','gent','germ','gets','gibe','gift','gigs','gild','gill','gilt','gins','gird','girl','gist','give','glad','glen','glib','glob','glom','glow','glue','glum','glut','gnat','gnaw','gnus','goad','goal','goat','gobs','gods','goes','gold','golf','gone','gong','good','goof','goon','gore','gory','gosh','gout','gown','grab','grad','gram','gray','grew','grey','grid','grim','grin','grip','grit','grow','grub','gulf','gull','gulp','gums','gunk','guns','guru','gush','gust','guts','guys','gyms','gyre','gyro',
                'hack','hail','hair','hale','half','hall','halo','halt','hams','hand','hang','hank','hard','hare','hark','harm','harp','hash','hasp','hate','hath','haul','have','hawk','haze','hazy','head','heal','heap','hear','heat','heck','heed','heel','heft','heir','held','hell','helm','help','hems','hens','herb','herd','here','hero','hers','hewn','hews','hick','hide','high','hike','hill','hilt','hind','hint','hips','hire','hiss','hits','hive','hoax','hobs','hock','hods','hoes','hogs','hold','hole','holy','home','hone','honk','hood','hoof','hook','hoop','hoot','hope','hops','horn','hose','host','hour','hove','howl','hubs','hued','hues','huge','hugs','hulk','hull','hums','hung','hunk','hunt','hurl','hurt','hush','husk','huts','hymn','hype','hypo',
                'ibex','ibis','iced','ices','icon','idea','idem','ides','idle','idly','idol','iffy','ills','imps','inch','info','inks','inky','inns','into','iota','iris','irks','iron','isle','itch','item','jack','jade','jail','jams','jars','jaws','jays','jazz','jean','jeep','jeer','jell','jerk','jest','jets','jibe','jibs','jigs','jilt','jive','jobs','jock','jogs','join','joke','jolt','jots','jowl','joys','judge','judo','jugs','jump','june','junk','jury','just','jute','kale','keel','keen','keep','kegs','kelp','kens','kept','keys','kick','kids','kill','kiln','kilo','kilt','kind','king','kink','kiss','kite','kits','kiwi','knee','knew','knit','knob','knot','know','lace','lack','lacy','lads','lady','lags','laid','lain','lair','lake','lamb','lame','lamp','land','lane','lank','laps','lard','lark','lash','lass','last','late','laud','lava','lawn','laws','lays','laze','lazy','lead','leaf','leak','lean','leap','learn','leash','least','leave','lede','leek','leer','lees','left','legs','lend','lens','lent','less','lest','lets','levy','lewd','liar','lice','lick','lids','lied','lien','lies','lieu','life','lift','like','lilt','lily','limb','lime','limp','line','link','lint','lion','lips','lira','lisp','list','lite','live','load','loaf','loam','loan','lobe','lobs','loch','lock','lode','loft','loge','logo','logs','loin','lone','long','look','loom','loon','loop','loot','lope','lord','lore','lorn','lose','loss','lost','loth','lots','loud','lout','love','lows','lube','luck','luge','lugs','lull','lump','luna','lung','lunk','lure','lurk','lush','lust','lute','lynx','lyre',
                'mace','made','mads','mage','magi','maid','mail','maim','main','make','male','mall','malt','mama','mane','mans','many','maps','mare','mark','marl','mars','mash','mask','mass','mast','mate','math','mats','maul','maws','maze','mead','meal','mean','meat','meek','meet','meld','melt','memo','mend','menu','meow','mere','mesh','mess','mica','mice','midi','mids','mien','mike','mild','mile','milk','mill','mime','mind','mine','mink','mint','minx','mire','miss','mist','mite','mitt','moan','moat','mobs','mock','mode','mods','mole','molt','moms','monk','mono','mood','moon','moor','moos','moot','mope','mops','more','morn','moss','most','moth','move','mows','much','muck','muds','mule','mull','mums','muse','mush','musk','must','mute','mutt','myth',
                'nabs','nags','nail','name','nape','naps','narc','nary','nave','navy','nays','near','neat','neck','need','neon','nerd','nest','nets','news','newt','next','nibs','nice','nick','nigh','nine','nips','nits','node','nods','noel','none','nook','noon','nope','norm','nose','nosy','note','noun','nova','nows','nubs','nude','nuke','null','numb','nuns','nuts',
                'oafs','oaks','oars','oath','oats','obey','oboe','odds','odes','odor','offs','ogre','ohed','ohms','oils','oily','oink','okay','okra','omen','omit','once','ones','only','onto','onus','oohs','ooze','oozy','opal','open','opts','opus','oral','orbs','orca','ores','orgy','otic','otto','ouch','ours','oust','outs','oval','oven','over','owed','owes','owls','owns','oxen','pace','pack','pact','pads','page','paid','pail','pain','pair','pale','pall','palm','pals','pane','pang','pans','pant','papa','paps','para','pare','park','pars','part','pass','past','pate','path','pats','pave','paws','pays','peak','peal','pear','peas','peat','peck','peek','peel','peep','peer','pegs','pelt','pens','pent','peon','peps','perk','perm','pert','peso','pest','pets','pews','phew','phone','phony','pick','pied','pier','pies','pigs','pike','pile','pill','pimp','pine','ping','pink','pins','pint','pipe','pips','piss','pith','pits','pity','plan','play','plea','pled','plot','plow','ploy','plug','plum','plus','pock','pods','poem','poet','poke','poky','pole','poll','polo','pomp','pond','pone','pony','poof','pool','poop','poor','pope','pops','pore','pork','porn','port','pose','posh','post','posy','pots','pour','pout','pram','pray','prep','prey','prim','prod','prof','prom','prop','prow','prude','prune','pubs','puck','puff','pugs','puke','pull','pulp','puma','pump','punk','puns','puny','pupa','pups','pure','purr','push','puss','puts','putt','pylon','pyre',
                'quack','quail','qualm','quark','quart','quash','quasi','quay','queen','queer','quell','query','quest','queue','quick','quiet','quiff','quill','quilt','quirk','quit','quite','quiz','quota','quote',
                'race','rack','racy','raft','rage','rags','raid','rail','rain','rake','ramp','rams','rang','rank','rant','rape','raps','rapt','rare','rash','rasp','rate','rats','rave','raws','rays','raze','razz','read','real','ream','reap','rear','redo','reds','reed','reef','reek','reel','refs','rein','rely','rend','rent','rest','revs','ribs','rice','rich','ride','rids','rife','rift','rigs','rile','rill','rims','rind','ring','rink','riot','ripe','rips','rise','risk','rite','road','roam','roan','roar','robe','robs','rock','rode','rods','roes','role','roll','romp','rood','roof','rook','room','root','rope','ropy','rose','rosy','rote','rots','rout','rove','rows','rube','rubs','ruby','ruck','rude','rued','rues','ruff','ruga','rugs','ruin','rule','rump','rums','rune','rung','runs','runt','ruse','rush','rusk','rust','ruts','ryes',
                'sack','sacs','safe','saga','sage','sago','sags','said','sail','sake','sale','salt','same','sand','sane','sang','sank','sans','saps','sari','sash','sass','sate','save','sawn','saws','says','scab','scad','scam','scan','scar','scat','scow','scud','scum','seal','seam','sear','seas','seat','sect','seed','seek','seem','seen','seep','seer','sees','self','sell','send','sent','serf','sets','sewn','sews','sexy','shad','shag','shah','sham','she','shed','ship','shiv','shod','shoe','shoo','shop','shot','show','shun','shut','sick','side','sift','sigh','sign','silk','sill','silo','silt','sine','sing','sink','sins','sips','sire','sirs','site','sits','size','skag','skat','skew','skid','skim','skin','skip','skis','skit','slab','slag','slam','slap','slat','slaw','slay','sled','slew','slid','slim','slip','slit','slob','sloe','slog','slop','slot','slow','slue','slug','slum','slur','smog','smug','snag','snap','snip','snit','snob','snot','snow','snub','snug','soak','soap','soar','sobs','sock','soda','sods','sofa','soft','soil','sold','sole','solo','some','song','sons','soon','soot','sops','sore','sort','sots','soul','soup','sour','sous','sown','sows','soya','soys','spam','span','spar','spas','spat','spay','spec','sped','spin','spit','spot','spry','spud','spun','spur','stab','stag','star','stat','stay','stem','step','stew','stir','stop','stow','stub','stud','stun','sty','stye','such','suck','suds','sued','sues','suit','sulk','sumo','sums','sung','sunk','suns','supe','sups','sure','surf','swab','swag','swam','swan','swap','swat','sway','swim','swum','sync',
                'tabs','tack','taco','tact','tads','tags','tail','take','tale','talk','tall','tame','tamp','tams','tang','tank','tans','tape','taps','tare','tarn','tarp','tars','tart','task','taut','taxi','teak','teal','team','tear','teas','teat','tech','teed','teem','teen','tees','tell','temp','tend','tens','tent','term','tern','test','text','than','that','thaw','thee','them','then','thew','they','thin','this','thou','thud','thug','thus','tick','tide','tidy','tied','tier','ties','tiff','tile','till','tilt','time','tine','ting','tins','tint','tiny','tips','tire','toad','tock','toed','toes','toff','togs','toil','told','toll','tomb','tome','toms','tone','tong','tons','tony','took','tool','toot','tops','tore','torn','tort','toss','tote','tots','tour','tout','town','tows','toys','tram','trap','tray','tree','trek','trim','trio','trip','trod','trot','trow','troy','true','tsar','tuba','tube','tubs','tuck','tuft','tugs','tuna','tune','tuns','turd','turf','turn','tusk','tutu','tux','twas','twig','twin','twit','twos','tyke','type','typo','tyro',
                'ugly','undo','unit','unto','upon','urge','urns','used','user','uses',
                'vain','vale','vamp','vane','vans','vary','vase','vast','vats','veal','veep','veer','veil','vein','vend','vent','verb','vers','very','vest','veto','vets','vial','vice','vied','vies','view','vile','vine','viol','visa','vise','void','volt','vote','vows','vows',
                'wade','wads','waft','wage','wags','waif','wail','wait','wake','walk','wall','wand','wane','want','ward','ware','warm','warn','warp','wars','wart','wary','wash','wasp','wave','wavy','waxy','ways','weak','weal','wean','wear','weds','weed','week','weep','weft','weir','weld','well','welt','wend','went','wept','were','west','wets','what','when','whet','whey','whim','whip','whir','whit','whiz','whom','wick','wide','wife','wigs','wild','wile','will','wilt','wily','wimp','wind','wine','wing','wink','wins','wipe','wire','wiry','wise','wish','wisp','with','wits','woke','wolf','womb','wont','wood','woof','wool','woos','word','wore','work','worm','worn','wort','wove','wows','wrap','wren','writ',
                'yack','yaks','yams','yank','yaps','yard','yarn','yawn','yaws','yeah','year','yeas','yell','yelp','yens','yeps','yeti','yews','yips','yoke','yolk','yore','your','yowl','yoyo','yuck','yule','yurt',
                'zany','zaps','zeal','zebu','zero','zest','zeta','zinc','zing','zips','zits','zone','zonk','zoom','zoos',
                
                // 5-letter words
                'about','above','abuse','actor','acute','admit','adopt','adult','after','again','agent','agree','ahead','alarm','album','alert','alike','alive','allow','alone','along','alter','amber','amend','among','ample','angel','anger','angle','angry','apart','apple','apply','arena','argue','arise','array','arrow','aside','asset','audio','avoid','awake','award','aware','badly','baker','bases','basic','basis','beach','began','begin','being','below','bench','billy','birth','black','blade','blame','blank','blend','blind','block','blood','board','boost','booth','bound','brain','brand','brave','bread','break','breed','brief','bring','broad','broke','brown','build','built','buyer','cable','calif','candy','carry','catch','cause','chain','chair','chaos','charm','chart','chase','cheap','check','chest','chief','child','china','chose','civil','claim','class','clean','clear','click','clock','close','coach','coast','could','count','court','cover','crack','craft','crash','crazy','cream','crime','cross','crowd','crown','crude','cycle','daily','dance','dated','dealt','death','debut','delay','delta','dense','depot','depth','doing','doubt','dozen','draft','drama','drank','drawn','dream','dress','drill','drink','drive','drove','dying','eager','early','earth','eight','elect','empty','enemy','enjoy','enter','entry','equal','error','event','every','exact','exist','extra','faith','false','fault','fiber','field','fifth','fifty','fight','final','first','fixed','flash','fleet','floor','fluid','focus','force','forth','forty','forum','found','frame','frank','fraud','fresh','front','fruit','fully','funny','giant','given','glass','globe','going','grace','grade','grand','grant','grass','great','green','gross','group','grown','guard','guess','guest','guide','happy','harry','heart','heavy','hence','henry','horse','hotel','house','human','ideal','image','imply','index','inner','input','issue','japan','jimmy','joint','jones','judge','known','label','large','laser','later','laugh','layer','learn','lease','least','leave','legal','lemon','level','lewis','light','limit','links','lives','local','logic','loose','lower','lucky','lunch','lying','magic','major','maker','march','maria','match','maybe','mayor','meant','media','metal','might','minor','minus','mixed','model','money','month','moral','motor','mount','mouse','mouth','movie','music','needs','never','newly','night','noise','north','noted','novel','nurse','occur','ocean','offer','often','order','other','ought','paint','panel','paper','party','peace','peter','phase','phone','photo','piece','pilot','pitch','place','plain','plane','plant','plate','point','pound','power','press','price','pride','prime','print','prior','prize','proof','proud','prove','queen','quick','quiet','quite','radio','raise','range','rapid','ratio','reach','ready','refer','right','rival','river','robin','roger','roman','rough','round','route','royal','rural','scale','scene','scope','score','sense','serve','seven','shall','shape','share','sharp','sheet','shelf','shell','shift','shine','shirt','shock','shoot','short','shown','sight','since','sixth','sixty','sized','skill','sleep','slide','small','smart','smile','smith','smoke','solid','solve','sorry','sound','south','space','spare','speak','speed','spend','spent','split','spoke','sport','staff','stage','stake','stand','start','state','steam','steel','stick','still','stock','stone','stood','store','storm','story','strip','stuck','study','stuff','style','sugar','suite','super','sweet','table','taken','taste','taxes','teach','terry','texas','thank','theft','their','theme','there','these','thick','thing','think','third','those','three','threw','throw','tight','times','title','today','tommy','topic','total','touch','tough','tower','track','trade','train','treat','trend','trial','tribe','trick','tried','tries','troop','truck','truly','trust','truth','twice','under','undue','union','unity','until','upper','upset','urban','usage','usual','valid','value','video','virus','visit','vital','vocal','voice','waste','watch','water','wheel','where','which','while','white','whole','whose','woman','women','world','worry','worse','worst','worth','would','wound','write','wrong','wrote','yield','young','youth'
            ];
            
            VALID_WORDS = new Set(fallbackWords);
            WORDS_LOADED = true;
            console.log(`Using fallback dictionary: ${VALID_WORDS.size} words loaded`);
        }',
                    'https://raw.githubusercontent.com/jonathanwelton/word-lists/main/4-letter-words.json',
                    'https://raw.githubusercontent.com/jonathanwelton/word-lists/main/5-letter-words.json',
                ];

                const responses = await Promise.all(urls.map(url => fetch(url)));
                const dataArrays = await Promise.all(responses.map(res => {
                    if (!res.ok) throw new Error(`Failed to fetch ${res.url}: ${res.status}`);
                    return res.json();
                }));

                const allWords = dataArrays.flat();
                VALID_WORDS = new Set(allWords);
                WORDS_LOADED = true;
                console.log(`Loaded ${VALID_WORDS.size} words (3–5 letters)`);
            } catch (error) {
                console.error('Error loading words:', error);
                // Fallback word list
                const fallbackWords = ['cat','dog','bat','rat','hat','mat','pat','sat','can','ran','pan','man','car','bar','tar','jar','ace','age','ate','are','ice','ape','axe','bed','bet','beg','den','pen','ten','hen','red','wed','fed','led','net','set','jet','let','met','pet','vet','wet','yet','big','dig','fig','pig','rig','wig','bin','fin','pin','sin','tin','win','bit','fit','hit','kit','lit','pit','sit','wit','box','fox','bus','cub','cup','cut','fun','gun','run','sun','gum','hum','sum','but','gut','hut','jut','nut','rut','bad','dad','had','lad','mad','pad','sad','bag','gag','hag','lag','nag','rag','tag','wag','dam','ham','jam','ram','ban','fan','tan','van','gap','lap','map','nap','rap','sap','tap','zap','far','war','wax','way','caw','jaw','law','paw','raw','saw','bay','day','gay','hay','jay','lay','may','pay','ray','say'];
                VALID_WORDS = new Set(fallbackWords);
                WORDS_LOADED = true;
            }
        }

        loadWords();

        // Load grid pools and daily challenges
        async function loadGameData() {
            try {
                const gridPoolsUrl = 'https://raw.githubusercontent.com/Sublime-Audio-Productions/public-policies/main/assets/grid_pools.json';
                const dailyChallengesUrl = 'https://raw.githubusercontent.com/Sublime-Audio-Productions/public-policies/main/assets/daily_challenges.json';

                const [gridPoolsRes, dailyChallengesRes] = await Promise.all([
                    fetch(gridPoolsUrl).catch(err => null),
                    fetch(dailyChallengesUrl).catch(err => null)
                ]);

                if (gridPoolsRes && gridPoolsRes.ok) {
                    GRID_POOLS = await gridPoolsRes.json();
                    console.log('Loaded grid pools from GitHub');
                }

                if (dailyChallengesRes && dailyChallengesRes.ok) {
                    DAILY_CHALLENGES_DATA = await dailyChallengesRes.json();
                    console.log('Loaded daily challenges from GitHub');
                }
            } catch (error) {
                console.warn('Could not load game data from GitHub:', error);
            }
        }

        loadGameData();

        // Fallback daily challenges (used if GitHub loading fails)

        const DAILY_CHALLENGES = {
            "2025-01-15": {
                classic: { "3": { letter: "W", row: 1, col: 1 }, "4": { letter: "S", row: 0, col: 2 }, "5": { letter: "T", row: 2, col: 2 }, "6": { letter: "R", row: 1, col: 3 } },
                scramble: { "3": ['CAT', 'ATE', 'TEN'], "4": ['CATS', 'ANTS', 'TARS', 'STAR'], "5": ['HEART', 'EARTH', 'AFTER', 'RIVER', 'TREES'], "6": ['PLAYER', 'LISTEN', 'ARTIST', 'YEASTS', 'ENLIST', 'RESENT'] }
            },
            "2025-01-16": {
                classic: { "3": { letter: "C", row: 0, col: 0 }, "4": { letter: "A", row: 2, col: 1 }, "5": { letter: "D", row: 3, col: 3 }, "6": { letter: "M", row: 2, col: 4 } },
                scramble: { "3": ['BAT', 'ART', 'TRY'], "4": ['BOAT', 'OARS', 'ARTS', 'TOSS'], "5": ['BREAD', 'REAMS', 'EASES', 'ASTER', 'DRESS'], "6": ['MASTER', 'ASTERS', 'STEAMS', 'TEASES', 'ERASES', 'RESENT'] }
            },
            "2025-01-17": {
                classic: { "3": { letter: "T", row: 2, col: 2 }, "4": { letter: "B", row: 1, col: 0 }, "5": { letter: "P", row: 0, col: 4 }, "6": { letter: "L", row: 3, col: 2 } },
                scramble: { "3": ['DOG', 'OAK', 'GET'], "4": ['DOGS', 'OAKS', 'GATE', 'SKYE'], "5": ['PHONE', 'HOUSE', 'OVERT', 'NESTS', 'ERASE'], "6": ['PHONES', 'HOUSES', 'OUSTER', 'NERVES', 'EVERTS', 'STRESS'] }
            },
            "2025-12-27": {
                classic: { "3": { letter: "A", row: 1, col: 0 }, "4": { letter: "R", row: 1, col: 1 }, "5": { letter: "E", row: 2, col: 2 }, "6": { letter: "S", row: 2, col: 3 } },
                scramble: { "3": ['SUN', 'USE', 'NET'], "4": ['WISE', 'ISLE', 'SLEW', 'EELS'], "5": ['WINTER', 'INLETS', 'NIGHTS', 'TEASES', 'ESTRE', 'RESIST'].map(w => w.slice(0,5)), "6": ['WINTER', 'INLETS', 'NIGHTS', 'TEASES', 'ESTEEM', 'RESIST'] }
            }
        };

        function getTodayDate() {
            const now = new Date();
            return now.toISOString().split('T')[0];
        }

        function getDailyChallengeData(date, gridSize) {
            const challenges = DAILY_CHALLENGES[date];
            return challenges ? challenges[gridSize.toString()] : null;
        }

        function isDailyChallengeCompleted(date, gridSize) {
            const key = `daily_${date}_${gridSize}`;
            return dailyCompletions.get(key) === true;
        }

        function markDailyChallengeCompleted(date, gridSize) {
            const key = `daily_${date}_${gridSize}`;
            dailyCompletions.set(key, true);
        }

        function drawBricks(scene, w, h) {
            const g = scene.add.graphics();
            for(let y=0; y<h; y+=40) {
                for(let x=0; x<w; x+=80) {
                    const off = (y/40)%2===0 ? 0 : 40;
                    g.fillStyle(0x1e3a5f, 1);
                    g.fillRect(x+off, y, 76, 36);
                    g.lineStyle(2, 0x2d5a8f);
                    g.strokeRect(x+off, y, 76, 36);
                }
            }
        }

        class ClassicModeScene extends Phaser.Scene {
            constructor() {
                super('ClassicMode');
                this.gridSize = 5;
                this.grid = [];
                this.cells = [];
                this.cellTexts = [];
                this.cellColors = [];
                this.selectedCell = null;
                this.startingCell = null;
                this.solutionGrid = null;
                this.cellSize = 0;
                this.startX = 0;
                this.startY = 0;
                this.uiScale = 1;
                this.isDailyMode = false;
                this.isFreeMode = false;
                this.isScrambleMode = false;
                this.todayDate = getTodayDate();
                this.startTime = null;
                this.highlightedRows = new Set();
                this.highlightedCols = new Set();
            }

            init(data) {
                this.gridSize = data.gridSize || 5;
                this.isDailyMode = data.isDailyMode || false;
                this.isFreeMode = data.isFreeMode || false;
                this.isScrambleMode = data.isScrambleMode || false;
                this.startTime = Date.now();
            }

            create() {
                if(!WORDS_LOADED) {
                    this.add.text(this.cameras.main.width/2, this.cameras.main.height/2, 'Loading words...', {
                        fontSize: '24px',
                        color: '#ffffff'
                    }).setOrigin(0.5);
                    
                    this.time.delayedCall(100, () => this.create());
                    return;
                }

                const {width, height} = this.cameras.main;
                const minDim = Math.min(width, height);
                this.uiScale = minDim / 750;

                drawBricks(this, width, height);

                const titleHeight = height * 0.12;
                this.add.rectangle(width/2, titleHeight/2, width, titleHeight, 0x2d3561);

                const titleText = this.isDailyMode ? 'DAILY CHALLENGE' : (this.isFreeMode ? 'FREE MODE' : 'CLASSIC MODE');
                this.add.text(width/2, titleHeight*0.35, titleText, {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(32*this.uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(6*this.uiScale)
                }).setOrigin(0.5);

                if(this.isDailyMode) {
                    this.add.text(width/2, titleHeight*0.7, this.todayDate, {
                        fontFamily: 'Arial',
                        fontSize: `${Math.floor(14*this.uiScale)}px`,
                        color: '#feca57'
                    }).setOrigin(0.5);
                } else {
                    this.createGridSizeSelector(width/2, titleHeight*0.75);
                }

                const keyboardHeight = height * 0.30;
                const checkButtonHeight = 60 * this.uiScale;
                const spacing = height * 0.015;
                
                const availableGridHeight = height - titleHeight - keyboardHeight - checkButtonHeight - spacing - (height * 0.04);
                
                this.cellSize = Math.floor(Math.min(availableGridHeight / this.gridSize, width * 0.85 / this.gridSize));

                this.startX = (width - this.cellSize * this.gridSize) / 2;
                const topSpace = titleHeight + height * 0.02;
                const gridHeight = this.cellSize * this.gridSize;
                const bottomSpace = height - keyboardHeight - checkButtonHeight - spacing;
                this.startY = topSpace + (bottomSpace - topSpace - gridHeight) / 2;

                this.generateValidGrid();
                
                if(this.isDailyMode) {
                    this.setupDailyChallenge();
                } else if(this.isFreeMode) {
                    this.setupFreeMode();
                } else {
                    this.pickRandomStartingLetter();
                }
                
                this.createGrid();
                this.createBackButton();
                this.createMenuButton();
                this.createCheckButton();
                this.createKeyboard();
                this.setupKeyboardInput();
            }

            setupKeyboardInput() {
                this.input.keyboard.on('keydown', (event) => {
                    const key = event.key.toUpperCase();
                    
                    // Letter keys
                    if (key.length === 1 && key >= 'A' && key <= 'Z') {
                        this.typeLetter(key);
                    }
                    // Backspace or Delete
                    else if (event.key === 'Backspace' || event.key === 'Delete') {
                        this.deleteLetter();
                    }
                    // Arrow keys for navigation
                    else if (event.key.startsWith('Arrow') && this.selectedCell) {
                        event.preventDefault();
                        const [r, c] = this.selectedCell;
                        let newR = r, newC = c;
                        
                        switch(event.key) {
                            case 'ArrowUp': newR = Math.max(0, r - 1); break;
                            case 'ArrowDown': newR = Math.min(this.gridSize - 1, r + 1); break;
                            case 'ArrowLeft': newC = Math.max(0, c - 1); break;
                            case 'ArrowRight': newC = Math.min(this.gridSize - 1, c + 1); break;
                        }
                        
                        if (newR !== r || newC !== c) {
                            this.selectCell(newR, newC);
                        }
                    }
                    // Enter to check solution
                    else if (event.key === 'Enter') {
                        this.checkSolution();
                    }
                });
            }

            createGridSizeSelector(x, y) {
                const buttonWidth = 55*this.uiScale;
                const spacing = 15*this.uiScale;
                const sizes = [3,4,5,6];
                const startX = x - ((sizes.length*buttonWidth + (sizes.length-1)*spacing)/2);

                sizes.forEach((size, i) => {
                    const btnX = startX + i*(buttonWidth+spacing) + buttonWidth/2;
                    const isSelected = size === this.gridSize;

                    const btn = this.add.rectangle(btnX, y, buttonWidth, buttonWidth*0.85, 
                        isSelected ? 0x1dd1a1 : 0x64748b).setInteractive();
                    btn.setStrokeStyle(3*this.uiScale, isSelected ? 0x10ac84 : 0x475569);

                    this.add.text(btnX, y, `${size}×${size}`, {
                        fontFamily: 'Arial Black',
                        fontSize: `${Math.floor(18*this.uiScale)}px`,
                        color: '#ffffff',
                        stroke: '#000000',
                        strokeThickness: Math.floor(3*this.uiScale)
                    }).setOrigin(0.5);

                    btn.on('pointerdown', () => {
                        if(size !== this.gridSize) {
                            this.scene.restart({gridSize: size, isDailyMode: this.isDailyMode, isFreeMode: this.isFreeMode});
                        }
                    });

                    btn.on('pointerover', () => {
                        if(size !== this.gridSize) {
                            this.tweens.add({targets: btn, scaleX: 1.1, scaleY: 1.1, duration: 100});
                        }
                    });

                    btn.on('pointerout', () => {
                        this.tweens.add({targets: btn, scaleX: 1, scaleY: 1, duration: 100});
                    });
                });
            }

            generateValidGrid() {
                // Try to use pre-generated grids from grid pools first
                if (GRID_POOLS && GRID_POOLS[this.gridSize] && GRID_POOLS[this.gridSize].grids) {
                    const grids = GRID_POOLS[this.gridSize].grids;
                    if (grids.length > 0) {
                        const randomGrid = Phaser.Math.RND.pick(grids);
                        this.solutionGrid = randomGrid.grid;
                        this.grid = Array.from({length: this.gridSize}, () => Array(this.gridSize).fill(''));
                        console.log(`Using pre-generated ${this.gridSize}x${this.gridSize} grid from pool`);
                        return;
                    }
                }
                
                // Fallback to generating grids on the fly
                const wordsArray = Array.from(VALID_WORDS).filter(w => w.length === this.gridSize);
                
                if(wordsArray.length === 0) {
                    this.grid = Array.from({length: this.gridSize}, () => Array(this.gridSize).fill(''));
                    return;
                }

                let attempts = 100;
                let success = false;
                let solutionGrid = null;

                for(let attempt = 0; attempt < attempts && !success; attempt++) {
                    const tempGrid = Array.from({length: this.gridSize}, () => Array(this.gridSize).fill(''));

                    for(let r = 0; r < this.gridSize; r++) {
                        const word = Phaser.Math.RND.pick(wordsArray);
                        for(let c = 0; c < this.gridSize; c++) {
                            tempGrid[r][c] = word[c].toUpperCase();
                        }
                    }

                    let allColumnsValid = true;
                    for(let c = 0; c < this.gridSize; c++) {
                        const colWord = tempGrid.map(row => row[c]).join('').toLowerCase();
                        if(!VALID_WORDS.has(colWord)) {
                            allColumnsValid = false;
                            break;
                        }
                    }

                    if(allColumnsValid) {
                        success = true;
                        solutionGrid = tempGrid;
                    }
                }

                if(success) {
                    this.solutionGrid = solutionGrid;
                    this.grid = Array.from({length: this.gridSize}, () => Array(this.gridSize).fill(''));
                } else {
                    this.grid = Array.from({length: this.gridSize}, () => Array(this.gridSize).fill(''));
                }
            }

            pickRandomStartingLetter() {
                if(!this.solutionGrid) {
                    const r = Phaser.Math.Between(0, this.gridSize-1);
                    const c = Phaser.Math.Between(0, this.gridSize-1);
                    this.startingCell = [r, c];
                    this.grid[r][c] = String.fromCharCode(65 + Phaser.Math.Between(0, 25));
                } else {
                    const r = Phaser.Math.Between(0, this.gridSize-1);
                    const c = Phaser.Math.Between(0, this.gridSize-1);
                    
                    this.startingCell = [r, c];
                    this.grid[r][c] = this.solutionGrid[r][c];
                }

                for(let row = 0; row < this.gridSize; row++) {
                    for(let col = 0; col < this.gridSize; col++) {
                        if(row !== this.startingCell[0] || col !== this.startingCell[1]) {
                            this.selectedCell = [row, col];
                            return;
                        }
                    }
                }
            }

            setupDailyChallenge() {
                const challengeData = getDailyChallengeData(this.todayDate, this.gridSize, 'classic');
                
                if(!challengeData || !this.solutionGrid) {
                    this.pickRandomStartingLetter();
                    return;
                }

                const {letter, row, col} = challengeData;
                this.startingCell = [row, col];
                this.grid[row][col] = letter.toUpperCase();

                for(let r = 0; r < this.gridSize; r++) {
                    for(let c = 0; c < this.gridSize; c++) {
                        if(r !== row || c !== col) {
                            this.selectedCell = [r, c];
                            return;
                        }
                    }
                }
            }

            setupFreeMode() {
                this.startingCell = null;
                this.selectedCell = [0, 0];
            }

            createGrid() {
                for(let r = 0; r < this.gridSize; r++) {
                    this.cells[r] = [];
                    this.cellTexts[r] = [];
                    this.cellColors[r] = [];

                    for(let c = 0; c < this.gridSize; c++) {
                        const x = this.startX + c*this.cellSize;
                        const y = this.startY + r*this.cellSize;
                        const size = this.cellSize * 0.92;

                        this.cellColors[r][c] = COLORS[Phaser.Math.Between(0, COLORS.length-1)];
                        this.add.rectangle(x+4*this.uiScale, y+4*this.uiScale, size, size, 0x000000, 0.3).setOrigin(0);

                        const isStartingCell = this.startingCell && this.startingCell[0]===r && this.startingCell[1]===c;
                        const cell = this.add.rectangle(x, y, size, size, this.grid[r][c] ? this.cellColors[r][c] : 0x2d3561).setOrigin(0);

                        cell.setStrokeStyle(isStartingCell ? 4*this.uiScale : 3*this.uiScale, isStartingCell ? 0xfeca57 : 0x1a1a2e);
                        cell.setInteractive();

                        const text = this.add.text(x+size/2, y+size/2, this.grid[r][c], {
                            fontFamily: 'Arial Black',
                            fontSize: `${Math.floor(this.cellSize*0.45)}px`,
                            color: '#ffffff',
                            stroke: '#000000',
                            strokeThickness: Math.floor(4*this.uiScale)
                        }).setOrigin(0.5);

                        if(!isStartingCell) {
                            cell.on('pointerdown', () => this.selectCell(r, c));
                        }

                        this.cells[r][c] = cell;
                        this.cellTexts[r][c] = text;
                    }
                }

                if(this.selectedCell) {
                    const [r,c] = this.selectedCell;
                    this.cells[r][c].setStrokeStyle(5*this.uiScale, 0xfeca57);
                }
            }

            selectCell(row, col) {
                if(this.startingCell && this.startingCell[0]===row && this.startingCell[1]===col) return;

                if(this.selectedCell) {
                    const [r,c] = this.selectedCell;
                    if(!this.startingCell || this.startingCell[0]!==r || this.startingCell[1]!==c) {
                        this.cells[r][c].setStrokeStyle(3*this.uiScale, 0x1a1a2e);
                    }
                }

                this.selectedCell = [row, col];
                this.cells[row][col].setStrokeStyle(5*this.uiScale, 0xfeca57);
                this.tweens.add({targets: this.cells[row][col], scale: 1.08, duration: 80, yoyo: true});
            }

            createKeyboard() {
                const {width, height} = this.cameras.main;
                const keyboardBottomMargin = height * 0.01;
                const keySize = Math.floor(Math.min(this.cellSize*0.55, width*0.09));
                const spacing = keySize * 1.12;
                
                const deleteKeyHeight = keySize;
                const deleteKeyY = height - deleteKeyHeight/2 - keyboardBottomMargin;
                const topRowY = deleteKeyY - spacing * 3.5;

                const rows = [10, 9, 7];
                const letters = 'Q W E R T Y U I O PA S D F G H J K L Z X C V B N M'.split(' ');
                let index = 0;

                rows.forEach((count, row) => {
                    const rowWidth = count * spacing;
                    const startX = (width - rowWidth)/2;
                    const y = topRowY + row*spacing;

                    for(let i = 0; i < count && index < letters.length; i++) {
                        const x = startX + i*spacing + spacing/2;

                        this.add.rectangle(x+2*this.uiScale, y+2*this.uiScale, keySize, keySize, 0x000000, 0.3);
                        const key = this.add.rectangle(x, y, keySize, keySize, COLORS[index % COLORS.length]).setInteractive();
                        key.setStrokeStyle(2*this.uiScale, 0x1a1a2e);

                        const letter = letters[index];
                        this.add.text(x, y, letter, {
                            fontFamily: 'Arial Black',
                            fontSize: `${Math.floor(keySize*0.5)}px`,
                            color: '#ffffff',
                            stroke: '#000000',
                            strokeThickness: Math.floor(3*this.uiScale)
                        }).setOrigin(0.5);

                        key.on('pointerdown', () => {
                            this.typeLetter(letter);
                            this.tweens.add({targets: key, y: y+2, duration: 50, yoyo: true});
                        });

                        index++;
                    }
                });

                const delWidth = keySize * 2.5;
                const delX = width/2;

                this.add.rectangle(delX+3*this.uiScale, deleteKeyY+3*this.uiScale, delWidth, keySize, 0x000000, 0.3);
                const delKey = this.add.rectangle(delX, deleteKeyY, delWidth, keySize, 0xff6b6b).setInteractive();
                delKey.setStrokeStyle(3*this.uiScale, 0xee5a6f);

                this.add.text(delX, deleteKeyY, 'DELETE', {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(keySize*0.45)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(3*this.uiScale)
                }).setOrigin(0.5);

                delKey.on('pointerdown', () => {
                    this.deleteLetter();
                    this.tweens.add({targets: delKey, y: deleteKeyY+2, duration: 50, yoyo: true});
                });
            }

            typeLetter(letter) {
                if(!this.selectedCell) {
                    outer: for(let r = 0; r < this.gridSize; r++) {
                        for(let c = 0; c < this.gridSize; c++) {
                            const isStarting = this.startingCell && this.startingCell[0]===r && this.startingCell[1]===c;
                            if(!this.grid[r][c] && !isStarting) {
                                this.selectCell(r, c);
                                break outer;
                            }
                        }
                    }
                }

                if(!this.selectedCell) return;
                const [r,c] = this.selectedCell;
                if(this.startingCell && this.startingCell[0]===r && this.startingCell[1]===c) return;

                this.grid[r][c] = letter;
                this.cellTexts[r][c].setText(letter);
                this.cells[r][c].setFillStyle(this.cellColors[r][c]);
                this.tweens.add({targets: this.cellTexts[r][c], scale: 1.3, duration: 100, yoyo: true});
            }

            deleteLetter() {
                if(!this.selectedCell) return;
                const [r,c] = this.selectedCell;

                if(this.startingCell && this.startingCell[0]===r && this.startingCell[1]===c) {
                    this.showMessage('Cannot delete starting letter!', 0xff6b6b);
                    return;
                }

                this.grid[r][c] = '';
                this.cellTexts[r][c].setText('');
                this.cells[r][c].setFillStyle(0x2d3561);
            }

            createBackButton() {
                const size = 48*this.uiScale;
                const x = size;
                const y = size;

                this.add.rectangle(x+2, y+2, size*2, size, 0x000000, 0.3);
                const btn = this.add.rectangle(x, y, size*2, size, 0x5f27cd).setInteractive();
                btn.setStrokeStyle(3*this.uiScale, 0x341f97);

                const buttonText = this.isDailyMode ? 'BACK' : 'RESET';
                this.add.text(x, y, buttonText, {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(16*this.uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(3*this.uiScale)
                }).setOrigin(0.5);

                btn.on('pointerdown', () => {
                    this.cameras.main.flash(200);
                    if(this.isDailyMode) {
                        this.time.delayedCall(200, () => this.scene.start('DailyChallengeMenu'));
                    } else {
                        this.time.delayedCall(200, () => this.scene.restart({gridSize: this.gridSize, isFreeMode: this.isFreeMode}));
                    }
                });
            }

            createMenuButton() {
                const {width} = this.cameras.main;
                const size = 48*this.uiScale;
                const x = width - size;
                const y = size;

                this.add.rectangle(x+2, y+2, size*2, size, 0x000000, 0.3);
                const btn = this.add.rectangle(x, y, size*2, size, 0xF97F51).setInteractive();
                btn.setStrokeStyle(3*this.uiScale, 0xC44569);

                this.add.text(x, y, 'MENU', {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(16*this.uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(3*this.uiScale)
                }).setOrigin(0.5);

                btn.on('pointerdown', () => {
                    this.cameras.main.flash(200);
                    this.time.delayedCall(200, () => this.scene.start('MainMenu'));
                });
            }

            createCheckButton() {
                const {width, height} = this.cameras.main;
                const keyboardBottomMargin = height * 0.01;
                const keySize = Math.floor(Math.min(this.cellSize*0.55, width*0.09));
                const spacing = keySize * 1.12;
                
                const deleteKeyHeight = keySize;
                const deleteKeyY = height - deleteKeyHeight/2 - keyboardBottomMargin;
                const topOfKeyboard = deleteKeyY - spacing * 3.5 - keySize/2;
                
                const buttonWidth = width * 0.7;
                const buttonHeight = 55 * this.uiScale;
                const gap = 10 * this.uiScale;
                const buttonY = topOfKeyboard - gap - buttonHeight/2;

                this.add.rectangle(width/2+3, buttonY+3, buttonWidth, buttonHeight, 0x000000, 0.3);
                const btn = this.add.rectangle(width/2, buttonY, buttonWidth, buttonHeight, 0x1dd1a1).setInteractive();
                btn.setStrokeStyle(4*this.uiScale, 0x10ac84);

                this.add.text(width/2, buttonY, 'CHECK SOLUTION ✓', {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(20*this.uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(4*this.uiScale)
                }).setOrigin(0.5);

                btn.on('pointerdown', () => {
                    this.checkSolution();
                    this.tweens.add({targets: btn, y: buttonY+3, duration: 50, yoyo: true});
                });

                btn.on('pointerover', () => {
                    this.tweens.add({targets: btn, scaleX: 1.02, scaleY: 1.02, duration: 100});
                });

                btn.on('pointerout', () => {
                    this.tweens.add({targets: btn, scaleX: 1, scaleY: 1, duration: 100});
                });
            }

            checkSolution() {
                let hasEmpty = false;
                let allValid = true;
                const invalidRows = new Set();
                const invalidCols = new Set();

                for(let r = 0; r < this.gridSize; r++) {
                    for(let c = 0; c < this.gridSize; c++) {
                        if(!this.grid[r][c]) hasEmpty = true;
                    }
                }

                if(hasEmpty) {
                    this.showMessage('Fill all cells!', 0xff6b6b);
                    return;
                }

                // Check rows
                for(let r = 0; r < this.gridSize; r++) {
                    const word = this.grid[r].join('').toLowerCase();
                    if(!VALID_WORDS.has(word)) {
                        allValid = false;
                        invalidRows.add(r);
                    }
                }

                // Check columns
                for(let c = 0; c < this.gridSize; c++) {
                    const word = this.grid.map(r => r[c]).join('').toLowerCase();
                    if(!VALID_WORDS.has(word)) {
                        allValid = false;
                        invalidCols.add(c);
                    }
                }

                if(allValid) {
                    // Update statistics
                    const elapsedTime = Math.floor((Date.now() - this.startTime) / 1000);
                    gameStats.gamesPlayed++;
                    gameStats.gamesWon++;
                    gameStats.totalTime += elapsedTime;
                    gameStats.bestTime = Math.min(gameStats.bestTime, elapsedTime);
                    gameStats.gridSizeStats[this.gridSize].played++;
                    gameStats.gridSizeStats[this.gridSize].won++;
                    
                    if(this.isDailyMode) {
                        const mode = this.isScrambleMode ? 'scramble' : 'classic';
                        markDailyChallengeCompleted(this.todayDate, this.gridSize, mode);
                        gameStats.currentStreak++;
                        gameStats.maxStreak = Math.max(gameStats.maxStreak, gameStats.currentStreak);
                    }
                    
                    this.highlightValidGrid();
                    this.time.delayedCall(800, () => this.showVictory(elapsedTime));
                } else {
                    gameStats.gamesPlayed++;
                    gameStats.gridSizeStats[this.gridSize].played++;
                    this.highlightInvalidWords(invalidRows, invalidCols);
                    this.showMessage('Invalid words highlighted in red!', 0xff6b6b);
                }
            }

            highlightValidGrid() {
                // Flash all cells green
                for(let r = 0; r < this.gridSize; r++) {
                    for(let c = 0; c < this.gridSize; c++) {
                        const cell = this.cells[r][c];
                        this.tweens.add({
                            targets: cell,
                            fillColor: 0x1dd1a1,
                            duration: 300,
                            yoyo: true,
                            onComplete: () => {
                                cell.setFillStyle(this.cellColors[r][c]);
                            }
                        });
                    }
                }
            }

            highlightInvalidWords(invalidRows, invalidCols) {
                // Flash invalid cells red
                for(let r = 0; r < this.gridSize; r++) {
                    for(let c = 0; c < this.gridSize; c++) {
                        if(invalidRows.has(r) || invalidCols.has(c)) {
                            const cell = this.cells[r][c];
                            this.tweens.add({
                                targets: cell,
                                fillColor: 0xff6b6b,
                                duration: 400,
                                yoyo: true,
                                repeat: 1,
                                onComplete: () => {
                                    cell.setFillStyle(this.cellColors[r][c]);
                                }
                            });
                        }
                    }
                }
            }

            showMessage(msg, color) {
                const {width, height} = this.cameras.main;
                
                const overlay = this.add.rectangle(width/2, height/2, width, height, 0x000000, 0.7);
                const msgWidth = width * 0.8;
                const msgHeight = 120 * this.uiScale;
                
                const msgBg = this.add.rectangle(width/2, height/2, msgWidth, msgHeight, color);
                msgBg.setStrokeStyle(4*this.uiScale, 0x000000);
                
                const text = this.add.text(width/2, height/2, msg, {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(24*this.uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(4*this.uiScale),
                    align: 'center',
                    wordWrap: { width: msgWidth - 40 }
                }).setOrigin(0.5);

                this.tweens.add({
                    targets: [overlay, msgBg, text],
                    alpha: 0,
                    duration: 2000,
                    delay: 1000,
                    onComplete: () => {
                        overlay.destroy();
                        msgBg.destroy();
                        text.destroy();
                    }
                });
            }

            showVictory(elapsedTime) {
                const {width, height} = this.cameras.main;

                for(let i = 0; i < 30; i++) {
                    const x = Phaser.Math.Between(0, width);
                    const y = Phaser.Math.Between(0, height);
                    const star = this.add.text(x, y, '⭐', {fontSize: `${Math.floor(30*this.uiScale)}px`});

                    this.tweens.add({
                        targets: star,
                        scale: 2,
                        alpha: 0,
                        angle: 360,
                        duration: 1500,
                        onComplete: () => star.destroy()
                    });
                }

                this.add.rectangle(width/2, height/2, width, height, 0x000000, 0.7);

                const text = this.add.text(width/2, height/2 - 100*this.uiScale, '🎉 COMPLETE! 🎉', {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(52*this.uiScale)}px`,
                    color: '#feca57',
                    stroke: '#000000',
                    strokeThickness: Math.floor(8*this.uiScale)
                }).setOrigin(0.5);

                this.tweens.add({
                    targets: text,
                    scale: 1.2,
                    yoyo: true,
                    repeat: -1,
                    duration: 500
                });

                // Show time
                const minutes = Math.floor(elapsedTime / 60);
                const seconds = elapsedTime % 60;
                const timeStr = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                this.add.text(width/2, height/2 - 30*this.uiScale, timeStr, {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(24*this.uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(4*this.uiScale)
                }).setOrigin(0.5);

                // Share button
                const shareBtn = this.add.rectangle(width/2, height/2 + 60*this.uiScale, 220*this.uiScale, 60*this.uiScale, 0x48DBFB);
                shareBtn.setStrokeStyle(4*this.uiScale, 0x0ABDE3);
                shareBtn.setInteractive();

                const shareText = this.add.text(width/2, height/2 + 60*this.uiScale, '📤 SHARE', {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(24*this.uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(4*this.uiScale)
                }).setOrigin(0.5);

                shareBtn.on('pointerdown', () => {
                    this.tweens.add({targets: shareBtn, scaleX: 0.95, scaleY: 0.95, duration: 100, yoyo: true});
                    this.shareGrid();
                });
            }

            shareGrid() {
                const vowels = new Set(['A', 'E', 'I', 'O', 'U']);
                let shareText = `Grid Complete ${this.gridSize}x${this.gridSize}\n\n`;

                for(let r = 0; r < this.gridSize; r++) {
                    for(let c = 0; c < this.gridSize; c++) {
                        const letter = this.grid[r][c];
                        
                        if(this.startingCell && this.startingCell[0] === r && this.startingCell[1] === c) {
                            shareText += letter + ' ';
                        } else if(vowels.has(letter)) {
                            shareText += '🟦';
                        } else {
                            shareText += '🟥';
                        }
                    }
                    shareText += '\n';
                }

                shareText += '\nCan you solve it? Play Grid Complete!';

                if(navigator.share) {
                    navigator.share({
                        title: 'Grid Complete',
                        text: shareText
                    }).catch(err => {
                        console.log('Share cancelled or failed:', err);
                        this.copyToClipboard(shareText);
                    });
                } else {
                    this.copyToClipboard(shareText);
                }
            }

            copyToClipboard(text) {
                if(navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(text).then(() => {
                        this.showMessage('Copied to clipboard! 📋', 0x1dd1a1);
                    }).catch(() => {
                        this.fallbackCopy(text);
                    });
                } else {
                    this.fallbackCopy(text);
                }
            }

            fallbackCopy(text) {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                document.body.appendChild(textArea);
                textArea.select();
                
                try {
                    document.execCommand('copy');
                    this.showMessage('Copied to clipboard! 📋', 0x1dd1a1);
                } catch(err) {
                    this.showMessage('Could not copy. Please share manually.', 0xff6b6b);
                }
                
                document.body.removeChild(textArea);
            }
        }

        class MainMenuScene extends Phaser.Scene {
            constructor() {
                super('MainMenu');
            }

            create() {
                const {width, height} = this.cameras.main;
                const minDim = Math.min(width, height);
                const uiScale = minDim / 750;

                drawBricks(this, width, height);

                const title = this.add.text(width/2, height*0.2, 'GRID\nCOMPLETE', {
                    fontSize: `${Math.floor(72*uiScale)}px`,
                    fontFamily: 'Arial Black',
                    color: '#ffffff',
                    align: 'center',
                    stroke: '#2d3561',
                    strokeThickness: Math.floor(10*uiScale)
                });
                title.setOrigin(0.5);
                title.setShadow(5, 5, '#000000', 10);

                this.tweens.add({
                    targets: title,
                    y: height*0.2 + 10,
                    duration: 1000,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });

                this.createButton(width/2, height*0.38, 'CLASSIC\nMODE', 0xFF6B6B, 0xEE5A6F, () => {
                    this.scene.start('ClassicMode', {gridSize: 5, isDailyMode: false, isFreeMode: false});
                });

                this.createButton(width/2, height*0.52, 'FREE\nMODE', 0x1DD1A1, 0x10ac84, () => {
                    this.scene.start('ClassicMode', {gridSize: 5, isDailyMode: false, isFreeMode: true});
                });

                this.createButton(width/2, height*0.66, 'DAILY\nCHALLENGE', 0xFECA57, 0xF97F51, () => {
                    this.scene.start('DailyChallengeMenu');
                });

                this.createButton(width/2, height*0.80, 'SCRAMBLE\nMODE', 0x48DBFB, 0x0ABDE3, () => {
                    this.scene.start('ScrambleMode');
                });

                this.createButton(width/2, height*0.92, '📊 STATS', 0x5F27CD, 0x341f97, () => {
                    this.scene.start('StatsScene');
                });
            }

            createButton(x, y, text, color1, color2, callback) {
                const container = this.add.container(x, y);

                const shadow = this.add.rectangle(8, 8, 280, 100, 0x000000, 0.3).setOrigin(0.5);
                const bottom = this.add.rectangle(4, 4, 280, 100, color2).setOrigin(0.5);
                const top = this.add.rectangle(0, 0, 280, 100, color1).setOrigin(0.5);

                const buttonText = this.add.text(0, 0, text, {
                    fontSize: '32px',
                    fontFamily: 'Arial Black',
                    color: '#ffffff',
                    align: 'center',
                    stroke: '#000000',
                    strokeThickness: 6
                }).setOrigin(0.5);

                container.add([shadow, bottom, top, buttonText]);
                container.setSize(280, 100);
                container.setInteractive();

                container.on('pointerover', () => {
                    this.tweens.add({targets: container, scale: 1.05, duration: 100});
                });

                container.on('pointerout', () => {
                    this.tweens.add({targets: container, scale: 1, duration: 100});
                });

                container.on('pointerdown', () => {
                    this.tweens.add({targets: [top, buttonText], y: 4, duration: 50});
                    this.cameras.main.flash(200);
                    this.time.delayedCall(200, callback);
                });

                container.on('pointerup', () => {
                    this.tweens.add({targets: [top, buttonText], y: 0, duration: 50});
                });
            }
        }

        class StatsScene extends Phaser.Scene {
            constructor() {
                super('StatsScene');
            }

            create() {
                const {width, height} = this.cameras.main;
                const minDim = Math.min(width, height);
                const uiScale = minDim / 750;

                drawBricks(this, width, height);

                // Title bar
                const titleHeight = height * 0.12;
                this.add.rectangle(width/2, titleHeight/2, width, titleHeight, 0x2d3561);
                this.add.text(width/2, titleHeight/2, 'STATISTICS', {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(36*uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(6*uiScale)
                }).setOrigin(0.5);

                const startY = titleHeight + 40*uiScale;
                const lineHeight = 50*uiScale;
                let currentY = startY;

                // Overall Stats
                this.createStatBox(width/2, currentY, 'OVERALL STATS', 0x48DBFB, uiScale);
                currentY += lineHeight;

                const winRate = gameStats.gamesPlayed > 0 
                    ? Math.floor((gameStats.gamesWon / gameStats.gamesPlayed) * 100) 
                    : 0;
                
                this.createStatLine(width/2, currentY, 'Games Played:', gameStats.gamesPlayed.toString(), uiScale);
                currentY += lineHeight * 0.8;
                this.createStatLine(width/2, currentY, 'Games Won:', gameStats.gamesWon.toString(), uiScale);
                currentY += lineHeight * 0.8;
                this.createStatLine(width/2, currentY, 'Win Rate:', `${winRate}%`, uiScale);
                currentY += lineHeight * 0.8;

                const avgTime = gameStats.gamesWon > 0 
                    ? Math.floor(gameStats.totalTime / gameStats.gamesWon) 
                    : 0;
                const avgMin = Math.floor(avgTime / 60);
                const avgSec = avgTime % 60;
                this.createStatLine(width/2, currentY, 'Avg Time:', `${avgMin}:${avgSec.toString().padStart(2, '0')}`, uiScale);
                currentY += lineHeight * 0.8;

                if(gameStats.bestTime !== Infinity) {
                    const bestMin = Math.floor(gameStats.bestTime / 60);
                    const bestSec = gameStats.bestTime % 60;
                    this.createStatLine(width/2, currentY, 'Best Time:', `${bestMin}:${bestSec.toString().padStart(2, '0')}`, uiScale);
                } else {
                    this.createStatLine(width/2, currentY, 'Best Time:', '--:--', uiScale);
                }
                currentY += lineHeight * 1.2;

                // Streak Stats
                this.createStatBox(width/2, currentY, 'DAILY STREAKS', 0xFECA57, uiScale);
                currentY += lineHeight;
                this.createStatLine(width/2, currentY, 'Current Streak:', gameStats.currentStreak.toString(), uiScale);
                currentY += lineHeight * 0.8;
                this.createStatLine(width/2, currentY, 'Max Streak:', gameStats.maxStreak.toString(), uiScale);
                currentY += lineHeight * 1.2;

                // Grid Size Stats
                this.createStatBox(width/2, currentY, 'BY GRID SIZE', 0x1DD1A1, uiScale);
                currentY += lineHeight;

                [3, 4, 5, 6].forEach(size => {
                    const stats = gameStats.gridSizeStats[size];
                    const sizeWinRate = stats.played > 0 
                        ? Math.floor((stats.won / stats.played) * 100) 
                        : 0;
                    this.createStatLine(
                        width/2, 
                        currentY, 
                        `${size}×${size} Grid:`, 
                        `${stats.won}/${stats.played} (${sizeWinRate}%)`, 
                        uiScale
                    );
                    currentY += lineHeight * 0.8;
                });

                // Back button
                this.createBackButton(48*uiScale, 48*uiScale, uiScale);
            }

            createStatBox(x, y, text, color, uiScale) {
                const width = 300 * uiScale;
                const height = 50 * uiScale;
                
                this.add.rectangle(x, y, width, height, color);
                this.add.rectangle(x, y, width, height, 0x000000, 0).setStrokeStyle(3*uiScale, 0x000000);
                
                this.add.text(x, y, text, {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(20*uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(4*uiScale)
                }).setOrigin(0.5);
            }

            createStatLine(x, y, label, value, uiScale) {
                const width = 320 * uiScale;
                
                this.add.text(x - width/2 + 20*uiScale, y, label, {
                    fontFamily: 'Arial',
                    fontSize: `${Math.floor(18*uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(2*uiScale)
                }).setOrigin(0, 0.5);
                
                this.add.text(x + width/2 - 20*uiScale, y, value, {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(18*uiScale)}px`,
                    color: '#feca57',
                    stroke: '#000000',
                    strokeThickness: Math.floor(3*uiScale)
                }).setOrigin(1, 0.5);
            }

            createBackButton(x, y, uiScale) {
                const size = 48*uiScale;
                this.add.rectangle(x+2, y+2, size*2, size, 0x000000, 0.3);
                const btn = this.add.rectangle(x, y, size*2, size, 0x5f27cd).setInteractive();
                btn.setStrokeStyle(3*uiScale, 0x341f97);

                this.add.text(x, y, 'BACK', {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(18*uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(3*uiScale)
                }).setOrigin(0.5);

                btn.on('pointerdown', () => {
                    this.cameras.main.flash(200);
                    this.time.delayedCall(200, () => this.scene.start('MainMenu'));
                });
            }
        }

        class DailyChallengeMenuScene extends Phaser.Scene {
            constructor() {
                super('DailyChallengeMenu');
            }

            create() {
                const {width, height} = this.cameras.main;
                const minDim = Math.min(width, height);
                const uiScale = minDim / 750;
                const todayDate = getTodayDate();

                drawBricks(this, width, height);

                this.add.rectangle(width/2, height*0.12, width, height*0.12, 0x2d3561);
                this.add.text(width/2, height*0.06, 'DAILY CHALLENGE', {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(32*uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(6*uiScale)
                }).setOrigin(0.5);

                this.add.text(width/2, height*0.10, todayDate, {
                    fontFamily: 'Arial',
                    fontSize: `${Math.floor(18*uiScale)}px`,
                    color: '#feca57'
                }).setOrigin(0.5);

                // Mode selector tabs
                this.createModeTabs(width/2, height*0.18, uiScale);

                // Grid size buttons
                const sizes = [3, 4, 5, 6];
                const startY = height * 0.30;
                const spacing = height * 0.15;

                sizes.forEach((size, i) => {
                    const y = startY + i * spacing;
                    const isClassicCompleted = isDailyChallengeCompleted(todayDate, size, 'classic');
                    const isScrambleCompleted = isDailyChallengeCompleted(todayDate, size, 'scramble');
                    const classicData = getDailyChallengeData(todayDate, size, 'classic');
                    const scrambleData = getDailyChallengeData(todayDate, size, 'scramble');

                    this.createChallengeButton(width/2, y, size, isClassicCompleted, isScrambleCompleted, 
                                               classicData, scrambleData, uiScale);
                });

                this.createBackButton(48*uiScale, 48*uiScale, uiScale);
            }

            createModeTabs(x, y, uiScale) {
                // This is now just informational text since both modes are shown together
                this.add.text(x, y, 'Complete both Classic & Scramble for each size!', {
                    fontFamily: 'Arial',
                    fontSize: `${Math.floor(16*uiScale)}px`,
                    color: '#feca57',
                    stroke: '#000000',
                    strokeThickness: Math.floor(2*uiScale)
                }).setOrigin(0.5);
            }

            createChallengeButton(x, y, size, isClassicCompleted, isScrambleCompleted, classicData, scrambleData, uiScale) {
                const container = this.add.container(x, y);

                // Main button background
                const allCompleted = isClassicCompleted && isScrambleCompleted;
                const someCompleted = isClassicCompleted || isScrambleCompleted;
                const hasData = classicData && scrambleData;
                
                const bgColor = allCompleted ? 0x1dd1a1 : (someCompleted ? 0xFECA57 : (hasData ? 0x48DBFB : 0x64748b));
                const borderColor = allCompleted ? 0x10ac84 : (someCompleted ? 0xF97F51 : (hasData ? 0x0ABDE3 : 0x475569));

                const shadow = this.add.rectangle(6, 6, 360, 100, 0x000000, 0.3).setOrigin(0.5);
                const bg = this.add.rectangle(0, 0, 360, 100, bgColor).setOrigin(0.5);
                bg.setStrokeStyle(4*uiScale, borderColor);

                const text = this.add.text(-150, -20, `${size}×${size} GRID`, {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(24*uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(4*uiScale)
                }).setOrigin(0, 0.5);

                // Classic status
                const classicStatus = isClassicCompleted ? '✓' : (classicData ? '▶' : '🔒');
                const classicColor = isClassicCompleted ? '#1dd1a1' : (classicData ? '#ffffff' : '#999999');
                const classicBtn = this.add.text(-150, 20, `Classic ${classicStatus}`, {
                    fontFamily: 'Arial',
                    fontSize: `${Math.floor(16*uiScale)}px`,
                    color: classicColor,
                    stroke: '#000000',
                    strokeThickness: Math.floor(2*uiScale)
                }).setOrigin(0, 0.5);

                // Scramble status
                const scrambleStatus = isScrambleCompleted ? '✓' : (scrambleData ? '▶' : '🔒');
                const scrambleColor = isScrambleCompleted ? '#1dd1a1' : (scrambleData ? '#ffffff' : '#999999');
                const scrambleBtn = this.add.text(50, 20, `Scramble ${scrambleStatus}`, {
                    fontFamily: 'Arial',
                    fontSize: `${Math.floor(16*uiScale)}px`,
                    color: scrambleColor,
                    stroke: '#000000',
                    strokeThickness: Math.floor(2*uiScale)
                }).setOrigin(0, 0.5);

                container.add([shadow, bg, text, classicBtn, scrambleBtn]);
                container.setSize(360, 100);

                // Make interactive if either mode is available and not completed
                if((classicData && !isClassicCompleted) || (scrambleData && !isScrambleCompleted)) {
                    container.setInteractive();

                    container.on('pointerdown', (pointer) => {
                        // Determine which mode was clicked based on x position
                        const localX = pointer.x - x;
                        
                        if(localX < 0 && classicData && !isClassicCompleted) {
                            // Classic mode clicked
                            this.cameras.main.flash(200);
                            this.time.delayedCall(200, () => {
                                this.scene.start('ClassicMode', {gridSize: size, isDailyMode: true, isScrambleMode: false});
                            });
                        } else if(localX >= 0 && scrambleData && !isScrambleCompleted) {
                            // Scramble mode clicked
                            this.cameras.main.flash(200);
                            this.time.delayedCall(200, () => {
                                this.scene.start('ScrambleMode', {gridSize: size, isDailyMode: true});
                            });
                        }
                    });

                    container.on('pointerover', () => {
                        this.tweens.add({targets: container, scale: 1.05, duration: 100});
                    });

                    container.on('pointerout', () => {
                        this.tweens.add({targets: container, scale: 1, duration: 100});
                    });
                }
            }

            createBackButton(x, y, uiScale) {
                this.add.rectangle(x+2, y+2, 90, 50, 0x000000, 0.3);
                const btn = this.add.rectangle(x, y, 90, 50, 0x5f27cd).setInteractive();
                btn.setStrokeStyle(3*uiScale, 0x341f97);

                this.add.text(x, y, 'BACK', {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(18*uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(3*uiScale)
                }).setOrigin(0.5);

                btn.on('pointerdown', () => {
                    this.cameras.main.flash(200);
                    this.time.delayedCall(200, () => this.scene.start('MainMenu'));
                });
            }
        }

        class ScrambleModeScene extends Phaser.Scene {
            constructor() { 
                super('ScrambleMode');
                this.gridSize = 4;
                this.isDailyMode = false;
                this.todayDate = getTodayDate();
                this.startTime = null;
            }

            init(data) {
                this.gridSize = data.gridSize || 4;
                this.isDailyMode = data.isDailyMode || false;
                this.startTime = Date.now();
            }
            
            create() {
                const w = this.cameras.main.width, h = this.cameras.main.height;
                const minDim = Math.min(w, h);
                this.uiScale = minDim / 750;

                this.drawBricks(w, h);
                
                this.genPuzzle();
                
                const titleHeight = h * 0.12;
                this.add.rectangle(w/2, titleHeight/2, w, titleHeight, 0x2d3561);
                
                const titleText = this.isDailyMode ? 'DAILY SCRAMBLE' : 'SCRAMBLE MODE';
                this.add.text(w/2, titleHeight*0.35, titleText, {
                    fontSize:`${Math.floor(32*this.uiScale)}px`,
                    fontFamily:'Arial Black',
                    color:'#fff',
                    stroke:'#000',
                    strokeThickness:Math.floor(6*this.uiScale)
                }).setOrigin(0.5);

                if(this.isDailyMode) {
                    this.add.text(w/2, titleHeight*0.7, this.todayDate, {
                        fontFamily: 'Arial',
                        fontSize: `${Math.floor(14*this.uiScale)}px`,
                        color: '#feca57'
                    }).setOrigin(0.5);
                } else {
                    this.createGridSizeSelector(w/2, titleHeight*0.75);
                }
                
                const checkButtonHeight = 60 * this.uiScale;
                const bottomMargin = h * 0.02;
                const availableGridHeight = h - titleHeight - checkButtonHeight - bottomMargin - (h * 0.08);
                
                this.cellSize = Math.floor(Math.min(availableGridHeight / this.gridSize, w * 0.85 / this.gridSize));
                this.startX = (w - this.cellSize * this.gridSize) / 2;
                
                const topSpace = titleHeight + h * 0.02;
                const gridHeight = this.cellSize * this.gridSize;
                const bottomSpace = h - checkButtonHeight - bottomMargin - (h * 0.04);
                this.startY = topSpace + (bottomSpace - topSpace - gridHeight) / 2;
                
                this.cells=[]; this.cellTexts=[]; this.cellContainers=[];
                for(let r=0; r<this.gridSize; r++) {
                    this.cells[r]=[]; this.cellTexts[r]=[]; this.cellContainers[r]=[];
                    for(let c=0; c<this.gridSize; c++) {
                        const x = this.startX+c*this.cellSize;
                        const y = this.startY+r*this.cellSize;
                        const size = this.cellSize * 0.92;
                        
                        const con = this.add.container(x, y);
                        const col = COLORS[(r*this.gridSize+c)%10];
                        const sh = this.add.rectangle(4*this.uiScale, 4*this.uiScale, size, size, 0x000000, 0.3).setOrigin(0);
                        const cell = this.add.rectangle(0, 0, size, size, col).setOrigin(0).setStrokeStyle(4*this.uiScale, 0x1a1a2e);
                        const txt = this.add.text(size/2, size/2, this.grid[r][c], {
                            fontSize:`${Math.floor(this.cellSize*0.45)}px`,
                            fontFamily:'Arial Black',
                            color:'#fff',
                            stroke:'#000',
                            strokeThickness:Math.floor(4*this.uiScale)
                        }).setOrigin(0.5);
                        con.add([sh,cell,txt]).setSize(size, size).setInteractive();
                        this.input.setDraggable(con);
                        con.row=r; con.col=c;
                        this.cells[r][c]=cell; this.cellTexts[r][c]=txt; this.cellContainers[r][c]=con;
                    }
                }
                
                this.input.on('dragstart', (p,o) => { o.setDepth(100); this.tweens.add({targets:o, scale:1.1, duration:100}); });
                this.input.on('drag', (p,o,dx,dy) => { o.x=dx; o.y=dy; });
                this.input.on('dragend', (p,o) => {
                    const dr=Math.floor((p.y-this.startY)/this.cellSize), dc=Math.floor((p.x-this.startX)/this.cellSize);
                    if(dr>=0 && dr<this.gridSize && dc>=0 && dc<this.gridSize) this.swapCells(o.row, o.col, dr, dc);
                    const fx=this.startX+o.col*this.cellSize, fy=this.startY+o.row*this.cellSize;
                    this.tweens.add({targets:o, x:fx, y:fy, scale:1, duration:200, ease:'Back.easeOut'});
                    o.setDepth(0);
                });
                
                this.makeBackBtn(48*this.uiScale, 48*this.uiScale, () => {
                    if(this.isDailyMode) {
                        this.scene.start('DailyChallengeMenu');
                    } else {
                        this.scene.start('MainMenu');
                    }
                });
                this.makeCheckBtn(w/2, h-70*this.uiScale, () => this.checkSolution());
            }

            createGridSizeSelector(x, y) {
                const buttonWidth = 55*this.uiScale;
                const spacing = 15*this.uiScale;
                const sizes = [3,4,5,6];
                const startX = x - ((sizes.length*buttonWidth + (sizes.length-1)*spacing)/2);

                sizes.forEach((size, i) => {
                    const btnX = startX + i*(buttonWidth+spacing) + buttonWidth/2;
                    const isSelected = size === this.gridSize;

                    const btn = this.add.rectangle(btnX, y, buttonWidth, buttonWidth*0.85, 
                        isSelected ? 0x1dd1a1 : 0x64748b).setInteractive();
                    btn.setStrokeStyle(3*this.uiScale, isSelected ? 0x10ac84 : 0x475569);

                    this.add.text(btnX, y, `${size}×${size}`, {
                        fontFamily: 'Arial Black',
                        fontSize: `${Math.floor(18*this.uiScale)}px`,
                        color: '#ffffff',
                        stroke: '#000000',
                        strokeThickness: Math.floor(3*this.uiScale)
                    }).setOrigin(0.5);

                    btn.on('pointerdown', () => {
                        if(size !== this.gridSize) {
                            this.scene.restart({gridSize: size});
                        }
                    });

                    btn.on('pointerover', () => {
                        if(size !== this.gridSize) {
                            this.tweens.add({targets: btn, scaleX: 1.1, scaleY: 1.1, duration: 100});
                        }
                    });

                    btn.on('pointerout', () => {
                        this.tweens.add({targets: btn, scaleX: 1, scaleY: 1, duration: 100});
                    });
                });
            }
            
            drawBricks(w, h) {
                const g = this.add.graphics();
                for(let y=0; y<h; y+=40) for(let x=0; x<w; x+=80) {
                    const off = (y/40)%2===0 ? 0 : 40;
                    g.fillStyle(0x1e3a5f, 1); g.fillRect(x+off, y, 76, 36);
                    g.lineStyle(2, 0x2d5a8f); g.strokeRect(x+off, y, 76, 36);
                }
            }
            
            genPuzzle() {
                // If daily mode, use the daily scramble from loaded data or fallback
                if(this.isDailyMode) {
                    const scrambleData = getDailyChallengeData(this.todayDate, this.gridSize, 'scramble');
                    if(scrambleData && scrambleData.solution) {
                        this.solution = scrambleData.solution.map(w => w.split(''));
                        this.grid = JSON.parse(JSON.stringify(this.solution));
                        
                        // Shuffle all letters
                        const letters = [];
                        for(let r=0; r<this.gridSize; r++) {
                            for(let c=0; c<this.gridSize; c++) {
                                letters.push(this.grid[r][c]);
                            }
                        }
                        
                        for(let i=letters.length-1; i>0; i--) { 
                            const j=Math.floor(Math.random()*(i+1)); 
                            [letters[i],letters[j]]=[letters[j],letters[i]]; 
                        }
                        
                        let idx=0;
                        for(let r=0; r<this.gridSize; r++) {
                            for(let c=0; c<this.gridSize; c++) {
                                this.grid[r][c]=letters[idx++];
                            }
                        }
                        return;
                    }
                }
                
                // Try to use pre-generated grids from grid pools
                if (GRID_POOLS && GRID_POOLS[this.gridSize] && GRID_POOLS[this.gridSize].grids) {
                    const grids = GRID_POOLS[this.gridSize].grids;
                    if (grids.length > 0) {
                        const randomGrid = Phaser.Math.RND.pick(grids);
                        this.solution = randomGrid.grid;
                        this.grid = JSON.parse(JSON.stringify(this.solution));
                        
                        // Shuffle all letters
                        const letters = [];
                        for(let r=0; r<this.gridSize; r++) {
                            for(let c=0; c<this.gridSize; c++) {
                                letters.push(this.grid[r][c]);
                            }
                        }
                        
                        for(let i=letters.length-1; i>0; i--) { 
                            const j=Math.floor(Math.random()*(i+1)); 
                            [letters[i],letters[j]]=[letters[j],letters[i]]; 
                        }
                        
                        let idx=0;
                        for(let r=0; r<this.gridSize; r++) {
                            for(let c=0; c<this.gridSize; c++) {
                                this.grid[r][c]=letters[idx++];
                            }
                        }
                        console.log(`Using pre-generated ${this.gridSize}x${this.gridSize} scramble from pool`);
                        return;
                    }
                }
                
                // Fallback to hardcoded scrambles
                const scrambles = {
                    3: ['CAT', 'ATE', 'TEN'],
                    4: ['CATS', 'ANTS', 'TARS', 'STAR'],
                    5: ['HEART', 'EARTH', 'AFTER', 'RIVER', 'TREES'],
                    6: ['PLAYER', 'LISTEN', 'ARTIST', 'YEASTS', 'ENLIST', 'RESENT']
                };

                const words = scrambles[this.gridSize] || scrambles[4];
                this.solution = words.map(w => w.split(''));
                this.grid = JSON.parse(JSON.stringify(this.solution));
                
                // Shuffle all letters
                const letters = [];
                for(let r=0; r<this.gridSize; r++) {
                    for(let c=0; c<this.gridSize; c++) {
                        letters.push(this.grid[r][c]);
                    }
                }
                
                for(let i=letters.length-1; i>0; i--) { 
                    const j=Math.floor(Math.random()*(i+1)); 
                    [letters[i],letters[j]]=[letters[j],letters[i]]; 
                }
                
                let idx=0;
                for(let r=0; r<this.gridSize; r++) {
                    for(let c=0; c<this.gridSize; c++) {
                        this.grid[r][c]=letters[idx++];
                    }
                }
            }
            
            swapCells(r1,c1,r2,c2) {
                if(r1===r2 && c1===c2) return;
                [this.grid[r1][c1], this.grid[r2][c2]] = [this.grid[r2][c2], this.grid[r1][c1]];
                [this.cellContainers[r1][c1].row, this.cellContainers[r2][c2].row] = [this.cellContainers[r2][c2].row, this.cellContainers[r1][c1].row];
                [this.cellContainers[r1][c1].col, this.cellContainers[r2][c2].col] = [this.cellContainers[r2][c2].col, this.cellContainers[r1][c1].col];
                [this.cellContainers[r1][c1], this.cellContainers[r2][c2]] = [this.cellContainers[r2][c2], this.cellContainers[r1][c1]];
                const tx=this.startX+c1*this.cellSize, ty=this.startY+r1*this.cellSize;
                this.tweens.add({targets:this.cellContainers[r1][c1], x:tx, y:ty, duration:200, ease:'Back.easeOut'});
            }
            
            makeBackBtn(x, y, fn) {
                const size = 48*this.uiScale;
                this.add.rectangle(x+2, y+2, size*2, size, 0x000000, 0.3);
                const b = this.add.rectangle(x, y, size*2, size, 0x5F27CD).setStrokeStyle(3*this.uiScale, 0x341f97).setInteractive();
                this.add.text(x, y, 'BACK', {
                    fontSize:`${Math.floor(16*this.uiScale)}px`,
                    fontFamily:'Arial Black',
                    color:'#fff',
                    stroke:'#000',
                    strokeThickness:Math.floor(3*this.uiScale)
                }).setOrigin(0.5);
                b.on('pointerdown', () => { this.cameras.main.flash(200); this.time.delayedCall(200, fn); });
            }
            
            makeCheckBtn(x, y, fn) {
                const buttonWidth = this.cameras.main.width * 0.7;
                const buttonHeight = 55 * this.uiScale;
                
                this.add.rectangle(x+3, y+3, buttonWidth, buttonHeight, 0x000000, 0.3);
                const b = this.add.rectangle(x, y, buttonWidth, buttonHeight, 0x1DD1A1).setStrokeStyle(4*this.uiScale, 0x10ac84).setInteractive();
                const t = this.add.text(x, y, 'CHECK SOLUTION ✓', {
                    fontSize:`${Math.floor(20*this.uiScale)}px`,
                    fontFamily:'Arial Black',
                    color:'#fff',
                    stroke:'#000',
                    strokeThickness:Math.floor(4*this.uiScale)
                }).setOrigin(0.5);
                b.on('pointerdown', () => { this.tweens.add({targets:[b,t], y:y+3, duration:50, yoyo:true}); fn(); });
                
                b.on('pointerover', () => {
                    this.tweens.add({targets: b, scaleX: 1.02, scaleY: 1.02, duration: 100});
                });

                b.on('pointerout', () => {
                    this.tweens.add({targets: b, scaleX: 1, scaleY: 1, duration: 100});
                });
            }
            
            checkSolution() {
                let valid = true;
                for(let r=0; r<this.gridSize; r++) {
                    if(!VALID_WORDS.has(this.grid[r].join('').toLowerCase())) valid=false;
                }
                for(let c=0; c<this.gridSize; c++) {
                    if(!VALID_WORDS.has(this.grid.map(r=>r[c]).join('').toLowerCase())) valid=false;
                }
                
                if(valid) {
                    // Update statistics
                    const elapsedTime = Math.floor((Date.now() - this.startTime) / 1000);
                    gameStats.gamesPlayed++;
                    gameStats.gamesWon++;
                    gameStats.totalTime += elapsedTime;
                    gameStats.bestTime = Math.min(gameStats.bestTime, elapsedTime);
                    gameStats.gridSizeStats[this.gridSize].played++;
                    gameStats.gridSizeStats[this.gridSize].won++;
                    
                    if(this.isDailyMode) {
                        markDailyChallengeCompleted(this.todayDate, this.gridSize, 'scramble');
                        gameStats.currentStreak++;
                        gameStats.maxStreak = Math.max(gameStats.maxStreak, gameStats.currentStreak);
                    }
                    
                    this.showVictory(elapsedTime);
                } else {
                    gameStats.gamesPlayed++;
                    gameStats.gridSizeStats[this.gridSize].played++;
                    this.showError();
                }
            }
            
            showVictory(elapsedTime) {
                const w = this.cameras.main.width, h = this.cameras.main.height;
                for(let i=0; i<40; i++) {
                    const emj = ['⭐','🎉','✨','🌟'][Phaser.Math.Between(0,3)];
                    const s = this.add.text(Phaser.Math.Between(0,w), Phaser.Math.Between(0,h), emj, {fontSize:'30px'});
                    this.tweens.add({targets:s, scale:2, alpha:0, angle:360, duration:1500, onComplete:()=>s.destroy()});
                }
                this.add.rectangle(w/2, h/2, w, h, 0x000000, 0.7);
                const t = this.add.text(w/2, h/2 - 40, '🎉 SOLVED! 🎉', {fontSize:'56px', fontFamily:'Arial Black', color:'#48DBFB', stroke:'#000', strokeThickness:8}).setOrigin(0.5);
                this.tweens.add({targets:t, scale:1.2, duration:500, yoyo:true, repeat:-1});
                
                // Show time
                const minutes = Math.floor(elapsedTime / 60);
                const seconds = elapsedTime % 60;
                const timeStr = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                this.add.text(w/2, h/2 + 20, timeStr, {
                    fontFamily: 'Arial Black',
                    fontSize: '24px',
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 4
                }).setOrigin(0.5);
            }
            
            showError() {
                const w = this.cameras.main.width;
                const bg = this.add.rectangle(w/2, 90, 300, 50, 0xFF6B6B).setStrokeStyle(3, 0xEE5A6F);
                const t = this.add.text(w/2, 90, 'Keep trying!', {fontSize:'24px', fontFamily:'Arial Black', color:'#fff', stroke:'#000', strokeThickness:4}).setOrigin(0.5);
                this.tweens.add({targets:[bg,t], alpha:0, y:70, duration:2000, onComplete:()=>{ bg.destroy(); t.destroy(); }});
            }
        }

        const config = {
            type: Phaser.AUTO,
            width: Math.min(600, window.innerWidth),
            height: Math.min(1280, window.innerHeight),
            parent: 'game-container',
            backgroundColor: '#1a1a2e',
            scene: [MainMenuScene, DailyChallengeMenuScene, ClassicModeScene, ScrambleModeScene, StatsScene],
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            }
        };

        new Phaser.Game(config);
    </script>
</body>
</html>