<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Complete - Classic Mode</title>
    <script>
window.onerror = function(message, source, lineno, colno, error) {
    alert(`Error: ${message}\nFile: ${source}\nLine: ${lineno}:${colno}`);
};

const originalError = console.error;
console.error = function(...args) {
    alert(args.join("\n"));
    originalError.apply(console, args);
};
</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #1a1a2e; }
        #game-container { display: flex; justify-content: center; align-items: center; width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <script>
        let VALID_WORDS = new Set();
        const COLORS = [0xFF6B6B,0xFECA57,0x48DBFB,0x1DD1A1,0xEE5A6F,0xC44569,0xF97F51,0x5F27CD,0x00D2D3,0x54A0FF];
        let WORDS_LOADED = false;
        let GRID_POOLS = null;
        let DAILY_CHALLENGES_DATA = null;

        // In-memory storage for daily challenge completions (replaces localStorage)
        const dailyCompletions = new Map();
        
        // Statistics storage
        const gameStats = {
            gamesPlayed: 0,
            gamesWon: 0,
            totalTime: 0,
            bestTime: Infinity,
            currentStreak: 0,
            maxStreak: 0,
            gridSizeStats: {
                3: { played: 0, won: 0 },
                4: { played: 0, won: 0 },
                5: { played: 0, won: 0 },
                6: { played: 0, won: 0 }
            }
        };

        async function loadWords() {
            try {
                const urls = [
                    'https://raw.githubusercontent.com/jonathanwelton/word-lists/main/3-letter-words.json',
                    'https://raw.githubusercontent.com/jonathanwelton/word-lists/main/4-letter-words.json',
                    'https://raw.githubusercontent.com/jonathanwelton/word-lists/main/5-letter-words.json',
                ];

                const responses = await Promise.all(urls.map(url => fetch(url)));
                const dataArrays = await Promise.all(responses.map(res => {
                    if (!res.ok) throw new Error(`Failed to fetch ${res.url}: ${res.status}`);
                    return res.json();
                }));

                const allWords = dataArrays.flat();
                VALID_WORDS = new Set(allWords);
                WORDS_LOADED = true;
                console.log(`Loaded ${VALID_WORDS.size} words (3â€“5 letters)`);
                alert('words loaded')
            } catch (error) {
                console.error('Error loading words:', error);
                // Fallback word list
                const fallbackWords = ['cat','dog','bat','rat','hat','mat','pat','sat','can','ran','pan','man','car','bar','tar','jar','ace','age','ate','are','ice','ape','axe','bed','bet','beg','den','pen','ten','hen','red','wed','fed','led','net','set','jet','let','met','pet','vet','wet','yet','big','dig','fig','pig','rig','wig','bin','fin','pin','sin','tin','win','bit','fit','hit','kit','lit','pit','sit','wit','box','fox','bus','cub','cup','cut','fun','gun','run','sun','gum','hum','sum','but','gut','hut','jut','nut','rut','bad','dad','had','lad','mad','pad','sad','bag','gag','hag','lag','nag','rag','tag','wag','dam','ham','jam','ram','ban','fan','tan','van','gap','lap','map','nap','rap','sap','tap','zap','far','war','wax','way','caw','jaw','law','paw','raw','saw','bay','day','gay','hay','jay','lay','may','pay','ray','say'];
                VALID_WORDS = new Set(fallbackWords);
                WORDS_LOADED = true;
            }
        }

        loadWords();

        // Load grid pools and daily challenges
        async function loadGameData() {
            try {
                const gridPoolsUrl = 'https://raw.githubusercontent.com/Sublime-Audio-Productions/public-policies/main/assets/grid_pools.json';
                const dailyChallengesUrl = 'https://raw.githubusercontent.com/Sublime-Audio-Productions/public-policies/main/assets/daily_challenges.json';

                const [gridPoolsRes, dailyChallengesRes] = await Promise.all([
                    fetch(gridPoolsUrl).catch(err => null),
                    fetch(dailyChallengesUrl).catch(err => null)
                ]);

                if (gridPoolsRes && gridPoolsRes.ok) {
                    GRID_POOLS = await gridPoolsRes.json();
                    alert('Loaded grid pools from GitHub');
                }

                if (dailyChallengesRes && dailyChallengesRes.ok) {
                    DAILY_CHALLENGES_DATA = await dailyChallengesRes.json();
                    alert('Loaded daily challenges from GitHub');
                }
            } catch (error) {
                console.warn('Could not load game data from GitHub:', error);
            }
        }

        loadGameData();

        // Fallback daily challenges (used if GitHub loading fails)

        const DAILY_CHALLENGES = {
            "2025-01-15": {
                classic: { "3": { letter: "W", row: 1, col: 1 }, "4": { letter: "S", row: 0, col: 2 }, "5": { letter: "T", row: 2, col: 2 }, "6": { letter: "R", row: 1, col: 3 } },
                scramble: { "3": ['CAT', 'ATE', 'TEN'], "4": ['CATS', 'ANTS', 'TARS', 'STAR'], "5": ['HEART', 'EARTH', 'AFTER', 'RIVER', 'TREES'], "6": ['PLAYER', 'LISTEN', 'ARTIST', 'YEASTS', 'ENLIST', 'RESENT'] }
            },
            "2025-01-16": {
                classic: { "3": { letter: "C", row: 0, col: 0 }, "4": { letter: "A", row: 2, col: 1 }, "5": { letter: "D", row: 3, col: 3 }, "6": { letter: "M", row: 2, col: 4 } },
                scramble: { "3": ['BAT', 'ART', 'TRY'], "4": ['BOAT', 'OARS', 'ARTS', 'TOSS'], "5": ['BREAD', 'REAMS', 'EASES', 'ASTER', 'DRESS'], "6": ['MASTER', 'ASTERS', 'STEAMS', 'TEASES', 'ERASES', 'RESENT'] }
            },
            "2025-01-17": {
                classic: { "3": { letter: "T", row: 2, col: 2 }, "4": { letter: "B", row: 1, col: 0 }, "5": { letter: "P", row: 0, col: 4 }, "6": { letter: "L", row: 3, col: 2 } },
                scramble: { "3": ['DOG', 'OAK', 'GET'], "4": ['DOGS', 'OAKS', 'GATE', 'SKYE'], "5": ['PHONE', 'HOUSE', 'OVERT', 'NESTS', 'ERASE'], "6": ['PHONES', 'HOUSES', 'OUSTER', 'NERVES', 'EVERTS', 'STRESS'] }
            },
            "2025-12-27": {
                classic: { "3": { letter: "A", row: 1, col: 0 }, "4": { letter: "R", row: 1, col: 1 }, "5": { letter: "E", row: 2, col: 2 }, "6": { letter: "S", row: 2, col: 3 } },
                scramble: { "3": ['SUN', 'USE', 'NET'], "4": ['WISE', 'ISLE', 'SLEW', 'EELS'], "5": ['WINTER', 'INLETS', 'NIGHTS', 'TEASES', 'ESTRE', 'RESIST'].map(w => w.slice(0,5)), "6": ['WINTER', 'INLETS', 'NIGHTS', 'TEASES', 'ESTEEM', 'RESIST'] }
            }
        };

        function getTodayDate() {
            const now = new Date();
            return now.toISOString().split('T')[0];
        }

        function getDailyChallengeData(date, gridSize) {
            const challenges = DAILY_CHALLENGES[date];
            return challenges ? challenges[gridSize.toString()] : null;
        }

        function isDailyChallengeCompleted(date, gridSize) {
            const key = `daily_${date}_${gridSize}`;
            return dailyCompletions.get(key) === true;
        }

        function markDailyChallengeCompleted(date, gridSize) {
            const key = `daily_${date}_${gridSize}`;
            dailyCompletions.set(key, true);
        }

        function drawBricks(scene, w, h) {
            const g = scene.add.graphics();
            for(let y=0; y<h; y+=40) {
                for(let x=0; x<w; x+=80) {
                    const off = (y/40)%2===0 ? 0 : 40;
                    g.fillStyle(0x1e3a5f, 1);
                    g.fillRect(x+off, y, 76, 36);
                    g.lineStyle(2, 0x2d5a8f);
                    g.strokeRect(x+off, y, 76, 36);
                }
            }
        }

        class ClassicModeScene extends Phaser.Scene {
            constructor() {
                super('ClassicMode');
                this.gridSize = 5;
                this.grid = [];
                this.cells = [];
                this.cellTexts = [];
                this.cellColors = [];
                this.selectedCell = null;
                this.startingCell = null;
                this.solutionGrid = null;
                this.cellSize = 0;
                this.startX = 0;
                this.startY = 0;
                this.uiScale = 1;
                this.isDailyMode = false;
                this.isFreeMode = false;
                this.isScrambleMode = false;
                this.todayDate = getTodayDate();
                this.startTime = null;
                this.highlightedRows = new Set();
                this.highlightedCols = new Set();
            }

            init(data) {
                this.gridSize = data.gridSize || 5;
                this.isDailyMode = data.isDailyMode || false;
                this.isFreeMode = data.isFreeMode || false;
                this.isScrambleMode = data.isScrambleMode || false;
                this.startTime = Date.now();
            }

            create() {
                if(!WORDS_LOADED) {
                    this.add.text(this.cameras.main.width/2, this.cameras.main.height/2, 'Loading words...', {
                        fontSize: '24px',
                        color: '#ffffff'
                    }).setOrigin(0.5);
                    
                    this.time.delayedCall(100, () => this.create());
                    return;
                }

                const {width, height} = this.cameras.main;
                const minDim = Math.min(width, height);
                this.uiScale = minDim / 750;

                drawBricks(this, width, height);

                const titleHeight = height * 0.12;
                this.add.rectangle(width/2, titleHeight/2, width, titleHeight, 0x2d3561);

                const titleText = this.isDailyMode ? 'DAILY CHALLENGE' : (this.isFreeMode ? 'FREE MODE' : 'CLASSIC MODE');
                this.add.text(width/2, titleHeight*0.35, titleText, {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(32*this.uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(6*this.uiScale)
                }).setOrigin(0.5);

                if(this.isDailyMode) {
                    this.add.text(width/2, titleHeight*0.7, this.todayDate, {
                        fontFamily: 'Arial',
                        fontSize: `${Math.floor(14*this.uiScale)}px`,
                        color: '#feca57'
                    }).setOrigin(0.5);
                } else {
                    this.createGridSizeSelector(width/2, titleHeight*0.75);
                }

                const keyboardHeight = height * 0.30;
                const checkButtonHeight = 60 * this.uiScale;
                const spacing = height * 0.015;
                
                const availableGridHeight = height - titleHeight - keyboardHeight - checkButtonHeight - spacing - (height * 0.04);
                
                this.cellSize = Math.floor(Math.min(availableGridHeight / this.gridSize, width * 0.85 / this.gridSize));

                this.startX = (width - this.cellSize * this.gridSize) / 2;
                const topSpace = titleHeight + height * 0.02;
                const gridHeight = this.cellSize * this.gridSize;
                const bottomSpace = height - keyboardHeight - checkButtonHeight - spacing;
                this.startY = topSpace + (bottomSpace - topSpace - gridHeight) / 2;

                this.generateValidGrid();
                
                if(this.isDailyMode) {
                    this.setupDailyChallenge();
                } else if(this.isFreeMode) {
                    this.setupFreeMode();
                } else {
                    this.pickRandomStartingLetter();
                }
                
                this.createGrid();
                this.createBackButton();
                this.createMenuButton();
                this.createCheckButton();
                this.createKeyboard();
                this.setupKeyboardInput();
            }

            setupKeyboardInput() {
                this.input.keyboard.on('keydown', (event) => {
                    const key = event.key.toUpperCase();
                    
                    // Letter keys
                    if (key.length === 1 && key >= 'A' && key <= 'Z') {
                        this.typeLetter(key);
                    }
                    // Backspace or Delete
                    else if (event.key === 'Backspace' || event.key === 'Delete') {
                        this.deleteLetter();
                    }
                    // Arrow keys for navigation
                    else if (event.key.startsWith('Arrow') && this.selectedCell) {
                        event.preventDefault();
                        const [r, c] = this.selectedCell;
                        let newR = r, newC = c;
                        
                        switch(event.key) {
                            case 'ArrowUp': newR = Math.max(0, r - 1); break;
                            case 'ArrowDown': newR = Math.min(this.gridSize - 1, r + 1); break;
                            case 'ArrowLeft': newC = Math.max(0, c - 1); break;
                            case 'ArrowRight': newC = Math.min(this.gridSize - 1, c + 1); break;
                        }
                        
                        if (newR !== r || newC !== c) {
                            this.selectCell(newR, newC);
                        }
                    }
                    // Enter to check solution
                    else if (event.key === 'Enter') {
                        this.checkSolution();
                    }
                });
            }

            createGridSizeSelector(x, y) {
                const buttonWidth = 55*this.uiScale;
                const spacing = 15*this.uiScale;
                const sizes = [3,4,5,6];
                const startX = x - ((sizes.length*buttonWidth + (sizes.length-1)*spacing)/2);

                sizes.forEach((size, i) => {
                    const btnX = startX + i*(buttonWidth+spacing) + buttonWidth/2;
                    const isSelected = size === this.gridSize;

                    const btn = this.add.rectangle(btnX, y, buttonWidth, buttonWidth*0.85, 
                        isSelected ? 0x1dd1a1 : 0x64748b).setInteractive();
                    btn.setStrokeStyle(3*this.uiScale, isSelected ? 0x10ac84 : 0x475569);

                    this.add.text(btnX, y, `${size}Ã—${size}`, {
                        fontFamily: 'Arial Black',
                        fontSize: `${Math.floor(18*this.uiScale)}px`,
                        color: '#ffffff',
                        stroke: '#000000',
                        strokeThickness: Math.floor(3*this.uiScale)
                    }).setOrigin(0.5);

                    btn.on('pointerdown', () => {
                        if(size !== this.gridSize) {
                            this.scene.restart({gridSize: size, isDailyMode: this.isDailyMode, isFreeMode: this.isFreeMode});
                        }
                    });

                    btn.on('pointerover', () => {
                        if(size !== this.gridSize) {
                            this.tweens.add({targets: btn, scaleX: 1.1, scaleY: 1.1, duration: 100});
                        }
                    });

                    btn.on('pointerout', () => {
                        this.tweens.add({targets: btn, scaleX: 1, scaleY: 1, duration: 100});
                    });
                });
            }

            generateValidGrid() {
                // Try to use pre-generated grids from grid pools first
                if (GRID_POOLS && GRID_POOLS[this.gridSize] && GRID_POOLS[this.gridSize].grids) {
                    const grids = GRID_POOLS[this.gridSize].grids;
                    if (grids.length > 0) {
                        const randomGrid = Phaser.Math.RND.pick(grids);
                        this.solutionGrid = randomGrid.grid;
                        this.grid = Array.from({length: this.gridSize}, () => Array(this.gridSize).fill(''));
                        console.log(`Using pre-generated ${this.gridSize}x${this.gridSize} grid from pool`);
                        return;
                    }
                }
                
                // Fallback to generating grids on the fly
                const wordsArray = Array.from(VALID_WORDS).filter(w => w.length === this.gridSize);
                
                if(wordsArray.length === 0) {
                    this.grid = Array.from({length: this.gridSize}, () => Array(this.gridSize).fill(''));
                    return;
                }

                let attempts = 100;
                let success = false;
                let solutionGrid = null;

                for(let attempt = 0; attempt < attempts && !success; attempt++) {
                    const tempGrid = Array.from({length: this.gridSize}, () => Array(this.gridSize).fill(''));

                    for(let r = 0; r < this.gridSize; r++) {
                        const word = Phaser.Math.RND.pick(wordsArray);
                        for(let c = 0; c < this.gridSize; c++) {
                            tempGrid[r][c] = word[c].toUpperCase();
                        }
                    }

                    let allColumnsValid = true;
                    for(let c = 0; c < this.gridSize; c++) {
                        const colWord = tempGrid.map(row => row[c]).join('').toLowerCase();
                        if(!VALID_WORDS.has(colWord)) {
                            allColumnsValid = false;
                            break;
                        }
                    }

                    if(allColumnsValid) {
                        success = true;
                        solutionGrid = tempGrid;
                    }
                }

                if(success) {
                    this.solutionGrid = solutionGrid;
                    this.grid = Array.from({length: this.gridSize}, () => Array(this.gridSize).fill(''));
                } else {
                    this.grid = Array.from({length: this.gridSize}, () => Array(this.gridSize).fill(''));
                }
            }

            pickRandomStartingLetter() {
                if(!this.solutionGrid) {
                    const r = Phaser.Math.Between(0, this.gridSize-1);
                    const c = Phaser.Math.Between(0, this.gridSize-1);
                    this.startingCell = [r, c];
                    this.grid[r][c] = String.fromCharCode(65 + Phaser.Math.Between(0, 25));
                } else {
                    const r = Phaser.Math.Between(0, this.gridSize-1);
                    const c = Phaser.Math.Between(0, this.gridSize-1);
                    
                    this.startingCell = [r, c];
                    this.grid[r][c] = this.solutionGrid[r][c];
                }

                for(let row = 0; row < this.gridSize; row++) {
                    for(let col = 0; col < this.gridSize; col++) {
                        if(row !== this.startingCell[0] || col !== this.startingCell[1]) {
                            this.selectedCell = [row, col];
                            return;
                        }
                    }
                }
            }

            setupDailyChallenge() {
                const challengeData = getDailyChallengeData(this.todayDate, this.gridSize, 'classic');
                
                if(!challengeData || !this.solutionGrid) {
                    this.pickRandomStartingLetter();
                    return;
                }

                const {letter, row, col} = challengeData;
                this.startingCell = [row, col];
                this.grid[row][col] = letter.toUpperCase();

                for(let r = 0; r < this.gridSize; r++) {
                    for(let c = 0; c < this.gridSize; c++) {
                        if(r !== row || c !== col) {
                            this.selectedCell = [r, c];
                            return;
                        }
                    }
                }
            }

            setupFreeMode() {
                this.startingCell = null;
                this.selectedCell = [0, 0];
            }

            createGrid() {
                for(let r = 0; r < this.gridSize; r++) {
                    this.cells[r] = [];
                    this.cellTexts[r] = [];
                    this.cellColors[r] = [];

                    for(let c = 0; c < this.gridSize; c++) {
                        const x = this.startX + c*this.cellSize;
                        const y = this.startY + r*this.cellSize;
                        const size = this.cellSize * 0.92;

                        this.cellColors[r][c] = COLORS[Phaser.Math.Between(0, COLORS.length-1)];
                        this.add.rectangle(x+4*this.uiScale, y+4*this.uiScale, size, size, 0x000000, 0.3).setOrigin(0);

                        const isStartingCell = this.startingCell && this.startingCell[0]===r && this.startingCell[1]===c;
                        const cell = this.add.rectangle(x, y, size, size, this.grid[r][c] ? this.cellColors[r][c] : 0x2d3561).setOrigin(0);

                        cell.setStrokeStyle(isStartingCell ? 4*this.uiScale : 3*this.uiScale, isStartingCell ? 0xfeca57 : 0x1a1a2e);
                        cell.setInteractive();

                        const text = this.add.text(x+size/2, y+size/2, this.grid[r][c], {
                            fontFamily: 'Arial Black',
                            fontSize: `${Math.floor(this.cellSize*0.45)}px`,
                            color: '#ffffff',
                            stroke: '#000000',
                            strokeThickness: Math.floor(4*this.uiScale)
                        }).setOrigin(0.5);

                        if(!isStartingCell) {
                            cell.on('pointerdown', () => this.selectCell(r, c));
                        }

                        this.cells[r][c] = cell;
                        this.cellTexts[r][c] = text;
                    }
                }

                if(this.selectedCell) {
                    const [r,c] = this.selectedCell;
                    this.cells[r][c].setStrokeStyle(5*this.uiScale, 0xfeca57);
                }
            }

            selectCell(row, col) {
                if(this.startingCell && this.startingCell[0]===row && this.startingCell[1]===col) return;

                if(this.selectedCell) {
                    const [r,c] = this.selectedCell;
                    if(!this.startingCell || this.startingCell[0]!==r || this.startingCell[1]!==c) {
                        this.cells[r][c].setStrokeStyle(3*this.uiScale, 0x1a1a2e);
                    }
                }

                this.selectedCell = [row, col];
                this.cells[row][col].setStrokeStyle(5*this.uiScale, 0xfeca57);
                this.tweens.add({targets: this.cells[row][col], scale: 1.08, duration: 80, yoyo: true});
            }

            createKeyboard() {
                const {width, height} = this.cameras.main;
                const keyboardBottomMargin = height * 0.01;
                const keySize = Math.floor(Math.min(this.cellSize*0.55, width*0.09));
                const spacing = keySize * 1.12;
                
                const deleteKeyHeight = keySize;
                const deleteKeyY = height - deleteKeyHeight/2 - keyboardBottomMargin;
                const topRowY = deleteKeyY - spacing * 3.5;

                const rows = [10, 9, 7];
                const letters = 'Q W E R T Y U I O PA S D F G H J K L Z X C V B N M'.split(' ');
                let index = 0;

                rows.forEach((count, row) => {
                    const rowWidth = count * spacing;
                    const startX = (width - rowWidth)/2;
                    const y = topRowY + row*spacing;

                    for(let i = 0; i < count && index < letters.length; i++) {
                        const x = startX + i*spacing + spacing/2;

                        this.add.rectangle(x+2*this.uiScale, y+2*this.uiScale, keySize, keySize, 0x000000, 0.3);
                        const key = this.add.rectangle(x, y, keySize, keySize, COLORS[index % COLORS.length]).setInteractive();
                        key.setStrokeStyle(2*this.uiScale, 0x1a1a2e);

                        const letter = letters[index];
                        this.add.text(x, y, letter, {
                            fontFamily: 'Arial Black',
                            fontSize: `${Math.floor(keySize*0.5)}px`,
                            color: '#ffffff',
                            stroke: '#000000',
                            strokeThickness: Math.floor(3*this.uiScale)
                        }).setOrigin(0.5);

                        key.on('pointerdown', () => {
                            this.typeLetter(letter);
                            this.tweens.add({targets: key, y: y+2, duration: 50, yoyo: true});
                        });

                        index++;
                    }
                });

                const delWidth = keySize * 2.5;
                const delX = width/2;

                this.add.rectangle(delX+3*this.uiScale, deleteKeyY+3*this.uiScale, delWidth, keySize, 0x000000, 0.3);
                const delKey = this.add.rectangle(delX, deleteKeyY, delWidth, keySize, 0xff6b6b).setInteractive();
                delKey.setStrokeStyle(3*this.uiScale, 0xee5a6f);

                this.add.text(delX, deleteKeyY, 'DELETE', {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(keySize*0.45)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(3*this.uiScale)
                }).setOrigin(0.5);

                delKey.on('pointerdown', () => {
                    this.deleteLetter();
                    this.tweens.add({targets: delKey, y: deleteKeyY+2, duration: 50, yoyo: true});
                });
            }

            typeLetter(letter) {
                if(!this.selectedCell) {
                    outer: for(let r = 0; r < this.gridSize; r++) {
                        for(let c = 0; c < this.gridSize; c++) {
                            const isStarting = this.startingCell && this.startingCell[0]===r && this.startingCell[1]===c;
                            if(!this.grid[r][c] && !isStarting) {
                                this.selectCell(r, c);
                                break outer;
                            }
                        }
                    }
                }

                if(!this.selectedCell) return;
                const [r,c] = this.selectedCell;
                if(this.startingCell && this.startingCell[0]===r && this.startingCell[1]===c) return;

                this.grid[r][c] = letter;
                this.cellTexts[r][c].setText(letter);
                this.cells[r][c].setFillStyle(this.cellColors[r][c]);
                this.tweens.add({targets: this.cellTexts[r][c], scale: 1.3, duration: 100, yoyo: true});
            }

            deleteLetter() {
                if(!this.selectedCell) return;
                const [r,c] = this.selectedCell;

                if(this.startingCell && this.startingCell[0]===r && this.startingCell[1]===c) {
                    this.showMessage('Cannot delete starting letter!', 0xff6b6b);
                    return;
                }

                this.grid[r][c] = '';
                this.cellTexts[r][c].setText('');
                this.cells[r][c].setFillStyle(0x2d3561);
            }

            createBackButton() {
                const size = 48*this.uiScale;
                const x = size;
                const y = size;

                this.add.rectangle(x+2, y+2, size*2, size, 0x000000, 0.3);
                const btn = this.add.rectangle(x, y, size*2, size, 0x5f27cd).setInteractive();
                btn.setStrokeStyle(3*this.uiScale, 0x341f97);

                const buttonText = this.isDailyMode ? 'BACK' : 'RESET';
                this.add.text(x, y, buttonText, {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(16*this.uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(3*this.uiScale)
                }).setOrigin(0.5);

                btn.on('pointerdown', () => {
                    this.cameras.main.flash(200);
                    if(this.isDailyMode) {
                        this.time.delayedCall(200, () => this.scene.start('DailyChallengeMenu'));
                    } else {
                        this.time.delayedCall(200, () => this.scene.restart({gridSize: this.gridSize, isFreeMode: this.isFreeMode}));
                    }
                });
            }

            createMenuButton() {
                const {width} = this.cameras.main;
                const size = 48*this.uiScale;
                const x = width - size;
                const y = size;

                this.add.rectangle(x+2, y+2, size*2, size, 0x000000, 0.3);
                const btn = this.add.rectangle(x, y, size*2, size, 0xF97F51).setInteractive();
                btn.setStrokeStyle(3*this.uiScale, 0xC44569);

                this.add.text(x, y, 'MENU', {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(16*this.uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(3*this.uiScale)
                }).setOrigin(0.5);

                btn.on('pointerdown', () => {
                    this.cameras.main.flash(200);
                    this.time.delayedCall(200, () => this.scene.start('MainMenu'));
                });
            }

            createCheckButton() {
                const {width, height} = this.cameras.main;
                const keyboardBottomMargin = height * 0.01;
                const keySize = Math.floor(Math.min(this.cellSize*0.55, width*0.09));
                const spacing = keySize * 1.12;
                
                const deleteKeyHeight = keySize;
                const deleteKeyY = height - deleteKeyHeight/2 - keyboardBottomMargin;
                const topOfKeyboard = deleteKeyY - spacing * 3.5 - keySize/2;
                
                const buttonWidth = width * 0.7;
                const buttonHeight = 55 * this.uiScale;
                const gap = 10 * this.uiScale;
                const buttonY = topOfKeyboard - gap - buttonHeight/2;

                this.add.rectangle(width/2+3, buttonY+3, buttonWidth, buttonHeight, 0x000000, 0.3);
                const btn = this.add.rectangle(width/2, buttonY, buttonWidth, buttonHeight, 0x1dd1a1).setInteractive();
                btn.setStrokeStyle(4*this.uiScale, 0x10ac84);

                this.add.text(width/2, buttonY, 'CHECK SOLUTION âœ“', {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(20*this.uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(4*this.uiScale)
                }).setOrigin(0.5);

                btn.on('pointerdown', () => {
                    this.checkSolution();
                    this.tweens.add({targets: btn, y: buttonY+3, duration: 50, yoyo: true});
                });

                btn.on('pointerover', () => {
                    this.tweens.add({targets: btn, scaleX: 1.02, scaleY: 1.02, duration: 100});
                });

                btn.on('pointerout', () => {
                    this.tweens.add({targets: btn, scaleX: 1, scaleY: 1, duration: 100});
                });
            }

            checkSolution() {
                let hasEmpty = false;
                let allValid = true;
                const invalidRows = new Set();
                const invalidCols = new Set();

                for(let r = 0; r < this.gridSize; r++) {
                    for(let c = 0; c < this.gridSize; c++) {
                        if(!this.grid[r][c]) hasEmpty = true;
                    }
                }

                if(hasEmpty) {
                    this.showMessage('Fill all cells!', 0xff6b6b);
                    return;
                }

                // Check rows
                for(let r = 0; r < this.gridSize; r++) {
                    const word = this.grid[r].join('').toLowerCase();
                    if(!VALID_WORDS.has(word)) {
                        allValid = false;
                        invalidRows.add(r);
                    }
                }

                // Check columns
                for(let c = 0; c < this.gridSize; c++) {
                    const word = this.grid.map(r => r[c]).join('').toLowerCase();
                    if(!VALID_WORDS.has(word)) {
                        allValid = false;
                        invalidCols.add(c);
                    }
                }

                if(allValid) {
                    // Update statistics
                    const elapsedTime = Math.floor((Date.now() - this.startTime) / 1000);
                    gameStats.gamesPlayed++;
                    gameStats.gamesWon++;
                    gameStats.totalTime += elapsedTime;
                    gameStats.bestTime = Math.min(gameStats.bestTime, elapsedTime);
                    gameStats.gridSizeStats[this.gridSize].played++;
                    gameStats.gridSizeStats[this.gridSize].won++;
                    
                    if(this.isDailyMode) {
                        const mode = this.isScrambleMode ? 'scramble' : 'classic';
                        markDailyChallengeCompleted(this.todayDate, this.gridSize, mode);
                        gameStats.currentStreak++;
                        gameStats.maxStreak = Math.max(gameStats.maxStreak, gameStats.currentStreak);
                    }
                    
                    this.highlightValidGrid();
                    this.time.delayedCall(800, () => this.showVictory(elapsedTime));
                } else {
                    gameStats.gamesPlayed++;
                    gameStats.gridSizeStats[this.gridSize].played++;
                    this.highlightInvalidWords(invalidRows, invalidCols);
                    this.showMessage('Invalid words highlighted in red!', 0xff6b6b);
                }
            }

            highlightValidGrid() {
                // Flash all cells green
                for(let r = 0; r < this.gridSize; r++) {
                    for(let c = 0; c < this.gridSize; c++) {
                        const cell = this.cells[r][c];
                        this.tweens.add({
                            targets: cell,
                            fillColor: 0x1dd1a1,
                            duration: 300,
                            yoyo: true,
                            onComplete: () => {
                                cell.setFillStyle(this.cellColors[r][c]);
                            }
                        });
                    }
                }
            }

            highlightInvalidWords(invalidRows, invalidCols) {
                // Flash invalid cells red
                for(let r = 0; r < this.gridSize; r++) {
                    for(let c = 0; c < this.gridSize; c++) {
                        if(invalidRows.has(r) || invalidCols.has(c)) {
                            const cell = this.cells[r][c];
                            this.tweens.add({
                                targets: cell,
                                fillColor: 0xff6b6b,
                                duration: 400,
                                yoyo: true,
                                repeat: 1,
                                onComplete: () => {
                                    cell.setFillStyle(this.cellColors[r][c]);
                                }
                            });
                        }
                    }
                }
            }

            showMessage(msg, color) {
                const {width, height} = this.cameras.main;
                
                const overlay = this.add.rectangle(width/2, height/2, width, height, 0x000000, 0.7);
                const msgWidth = width * 0.8;
                const msgHeight = 120 * this.uiScale;
                
                const msgBg = this.add.rectangle(width/2, height/2, msgWidth, msgHeight, color);
                msgBg.setStrokeStyle(4*this.uiScale, 0x000000);
                
                const text = this.add.text(width/2, height/2, msg, {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(24*this.uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(4*this.uiScale),
                    align: 'center',
                    wordWrap: { width: msgWidth - 40 }
                }).setOrigin(0.5);

                this.tweens.add({
                    targets: [overlay, msgBg, text],
                    alpha: 0,
                    duration: 2000,
                    delay: 1000,
                    onComplete: () => {
                        overlay.destroy();
                        msgBg.destroy();
                        text.destroy();
                    }
                });
            }

            showVictory(elapsedTime) {
                const {width, height} = this.cameras.main;

                for(let i = 0; i < 30; i++) {
                    const x = Phaser.Math.Between(0, width);
                    const y = Phaser.Math.Between(0, height);
                    const star = this.add.text(x, y, 'â­', {fontSize: `${Math.floor(30*this.uiScale)}px`});

                    this.tweens.add({
                        targets: star,
                        scale: 2,
                        alpha: 0,
                        angle: 360,
                        duration: 1500,
                        onComplete: () => star.destroy()
                    });
                }

                this.add.rectangle(width/2, height/2, width, height, 0x000000, 0.7);

                const text = this.add.text(width/2, height/2 - 100*this.uiScale, 'ðŸŽ‰ COMPLETE! ðŸŽ‰', {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(52*this.uiScale)}px`,
                    color: '#feca57',
                    stroke: '#000000',
                    strokeThickness: Math.floor(8*this.uiScale)
                }).setOrigin(0.5);

                this.tweens.add({
                    targets: text,
                    scale: 1.2,
                    yoyo: true,
                    repeat: -1,
                    duration: 500
                });

                // Show time
                const minutes = Math.floor(elapsedTime / 60);
                const seconds = elapsedTime % 60;
                const timeStr = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                this.add.text(width/2, height/2 - 30*this.uiScale, timeStr, {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(24*this.uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(4*this.uiScale)
                }).setOrigin(0.5);

                // Share button
                const shareBtn = this.add.rectangle(width/2, height/2 + 60*this.uiScale, 220*this.uiScale, 60*this.uiScale, 0x48DBFB);
                shareBtn.setStrokeStyle(4*this.uiScale, 0x0ABDE3);
                shareBtn.setInteractive();

                const shareText = this.add.text(width/2, height/2 + 60*this.uiScale, 'ðŸ“¤ SHARE', {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(24*this.uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(4*this.uiScale)
                }).setOrigin(0.5);

                shareBtn.on('pointerdown', () => {
                    this.tweens.add({targets: shareBtn, scaleX: 0.95, scaleY: 0.95, duration: 100, yoyo: true});
                    this.shareGrid();
                });
            }

            shareGrid() {
                const vowels = new Set(['A', 'E', 'I', 'O', 'U']);
                let shareText = `Grid Complete ${this.gridSize}x${this.gridSize}\n\n`;

                for(let r = 0; r < this.gridSize; r++) {
                    for(let c = 0; c < this.gridSize; c++) {
                        const letter = this.grid[r][c];
                        
                        if(this.startingCell && this.startingCell[0] === r && this.startingCell[1] === c) {
                            shareText += letter + ' ';
                        } else if(vowels.has(letter)) {
                            shareText += 'ðŸŸ¦';
                        } else {
                            shareText += 'ðŸŸ¥';
                        }
                    }
                    shareText += '\n';
                }

                shareText += '\nCan you solve it? Play Grid Complete!';

                if(navigator.share) {
                    navigator.share({
                        title: 'Grid Complete',
                        text: shareText
                    }).catch(err => {
                        console.log('Share cancelled or failed:', err);
                        this.copyToClipboard(shareText);
                    });
                } else {
                    this.copyToClipboard(shareText);
                }
            }

            copyToClipboard(text) {
                if(navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(text).then(() => {
                        this.showMessage('Copied to clipboard! ðŸ“‹', 0x1dd1a1);
                    }).catch(() => {
                        this.fallbackCopy(text);
                    });
                } else {
                    this.fallbackCopy(text);
                }
            }

            fallbackCopy(text) {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                document.body.appendChild(textArea);
                textArea.select();
                
                try {
                    document.execCommand('copy');
                    this.showMessage('Copied to clipboard! ðŸ“‹', 0x1dd1a1);
                } catch(err) {
                    this.showMessage('Could not copy. Please share manually.', 0xff6b6b);
                }
                
                document.body.removeChild(textArea);
            }
        }

        class MainMenuScene extends Phaser.Scene {
            constructor() {
                super('MainMenu');
            }

            create() {
                const {width, height} = this.cameras.main;
                const minDim = Math.min(width, height);
                const uiScale = minDim / 750;

                drawBricks(this, width, height);

                const title = this.add.text(width/2, height*0.2, 'GRID\nCOMPLETE', {
                    fontSize: `${Math.floor(72*uiScale)}px`,
                    fontFamily: 'Arial Black',
                    color: '#ffffff',
                    align: 'center',
                    stroke: '#2d3561',
                    strokeThickness: Math.floor(10*uiScale)
                });
                title.setOrigin(0.5);
                title.setShadow(5, 5, '#000000', 10);

                this.tweens.add({
                    targets: title,
                    y: height*0.2 + 10,
                    duration: 1000,
                    yoyo: true,
                    repeat: -1,
                    ease: 'Sine.easeInOut'
                });

                this.createButton(width/2, height*0.38, 'CLASSIC\nMODE', 0xFF6B6B, 0xEE5A6F, () => {
                    this.scene.start('ClassicMode', {gridSize: 5, isDailyMode: false, isFreeMode: false});
                });

                this.createButton(width/2, height*0.52, 'FREE\nMODE', 0x1DD1A1, 0x10ac84, () => {
                    this.scene.start('ClassicMode', {gridSize: 5, isDailyMode: false, isFreeMode: true});
                });

                this.createButton(width/2, height*0.66, 'DAILY\nCHALLENGE', 0xFECA57, 0xF97F51, () => {
                    this.scene.start('DailyChallengeMenu');
                });

                this.createButton(width/2, height*0.80, 'SCRAMBLE\nMODE', 0x48DBFB, 0x0ABDE3, () => {
                    this.scene.start('ScrambleMode');
                });

                this.createButton(width/2, height*0.92, 'ðŸ“Š STATS', 0x5F27CD, 0x341f97, () => {
                    this.scene.start('StatsScene');
                });
            }

            createButton(x, y, text, color1, color2, callback) {
                const container = this.add.container(x, y);

                const shadow = this.add.rectangle(8, 8, 280, 100, 0x000000, 0.3).setOrigin(0.5);
                const bottom = this.add.rectangle(4, 4, 280, 100, color2).setOrigin(0.5);
                const top = this.add.rectangle(0, 0, 280, 100, color1).setOrigin(0.5);

                const buttonText = this.add.text(0, 0, text, {
                    fontSize: '32px',
                    fontFamily: 'Arial Black',
                    color: '#ffffff',
                    align: 'center',
                    stroke: '#000000',
                    strokeThickness: 6
                }).setOrigin(0.5);

                container.add([shadow, bottom, top, buttonText]);
                container.setSize(280, 100);
                container.setInteractive();

                container.on('pointerover', () => {
                    this.tweens.add({targets: container, scale: 1.05, duration: 100});
                });

                container.on('pointerout', () => {
                    this.tweens.add({targets: container, scale: 1, duration: 100});
                });

                container.on('pointerdown', () => {
                    this.tweens.add({targets: [top, buttonText], y: 4, duration: 50});
                    this.cameras.main.flash(200);
                    this.time.delayedCall(200, callback);
                });

                container.on('pointerup', () => {
                    this.tweens.add({targets: [top, buttonText], y: 0, duration: 50});
                });
            }
        }

        class StatsScene extends Phaser.Scene {
            constructor() {
                super('StatsScene');
            }

            create() {
                const {width, height} = this.cameras.main;
                const minDim = Math.min(width, height);
                const uiScale = minDim / 750;

                drawBricks(this, width, height);

                // Title bar
                const titleHeight = height * 0.12;
                this.add.rectangle(width/2, titleHeight/2, width, titleHeight, 0x2d3561);
                this.add.text(width/2, titleHeight/2, 'STATISTICS', {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(36*uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(6*uiScale)
                }).setOrigin(0.5);

                const startY = titleHeight + 40*uiScale;
                const lineHeight = 50*uiScale;
                let currentY = startY;

                // Overall Stats
                this.createStatBox(width/2, currentY, 'OVERALL STATS', 0x48DBFB, uiScale);
                currentY += lineHeight;

                const winRate = gameStats.gamesPlayed > 0 
                    ? Math.floor((gameStats.gamesWon / gameStats.gamesPlayed) * 100) 
                    : 0;
                
                this.createStatLine(width/2, currentY, 'Games Played:', gameStats.gamesPlayed.toString(), uiScale);
                currentY += lineHeight * 0.8;
                this.createStatLine(width/2, currentY, 'Games Won:', gameStats.gamesWon.toString(), uiScale);
                currentY += lineHeight * 0.8;
                this.createStatLine(width/2, currentY, 'Win Rate:', `${winRate}%`, uiScale);
                currentY += lineHeight * 0.8;

                const avgTime = gameStats.gamesWon > 0 
                    ? Math.floor(gameStats.totalTime / gameStats.gamesWon) 
                    : 0;
                const avgMin = Math.floor(avgTime / 60);
                const avgSec = avgTime % 60;
                this.createStatLine(width/2, currentY, 'Avg Time:', `${avgMin}:${avgSec.toString().padStart(2, '0')}`, uiScale);
                currentY += lineHeight * 0.8;

                if(gameStats.bestTime !== Infinity) {
                    const bestMin = Math.floor(gameStats.bestTime / 60);
                    const bestSec = gameStats.bestTime % 60;
                    this.createStatLine(width/2, currentY, 'Best Time:', `${bestMin}:${bestSec.toString().padStart(2, '0')}`, uiScale);
                } else {
                    this.createStatLine(width/2, currentY, 'Best Time:', '--:--', uiScale);
                }
                currentY += lineHeight * 1.2;

                // Streak Stats
                this.createStatBox(width/2, currentY, 'DAILY STREAKS', 0xFECA57, uiScale);
                currentY += lineHeight;
                this.createStatLine(width/2, currentY, 'Current Streak:', gameStats.currentStreak.toString(), uiScale);
                currentY += lineHeight * 0.8;
                this.createStatLine(width/2, currentY, 'Max Streak:', gameStats.maxStreak.toString(), uiScale);
                currentY += lineHeight * 1.2;

                // Grid Size Stats
                this.createStatBox(width/2, currentY, 'BY GRID SIZE', 0x1DD1A1, uiScale);
                currentY += lineHeight;

                [3, 4, 5, 6].forEach(size => {
                    const stats = gameStats.gridSizeStats[size];
                    const sizeWinRate = stats.played > 0 
                        ? Math.floor((stats.won / stats.played) * 100) 
                        : 0;
                    this.createStatLine(
                        width/2, 
                        currentY, 
                        `${size}Ã—${size} Grid:`, 
                        `${stats.won}/${stats.played} (${sizeWinRate}%)`, 
                        uiScale
                    );
                    currentY += lineHeight * 0.8;
                });

                // Back button
                this.createBackButton(48*uiScale, 48*uiScale, uiScale);
            }

            createStatBox(x, y, text, color, uiScale) {
                const width = 300 * uiScale;
                const height = 50 * uiScale;
                
                this.add.rectangle(x, y, width, height, color);
                this.add.rectangle(x, y, width, height, 0x000000, 0).setStrokeStyle(3*uiScale, 0x000000);
                
                this.add.text(x, y, text, {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(20*uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(4*uiScale)
                }).setOrigin(0.5);
            }

            createStatLine(x, y, label, value, uiScale) {
                const width = 320 * uiScale;
                
                this.add.text(x - width/2 + 20*uiScale, y, label, {
                    fontFamily: 'Arial',
                    fontSize: `${Math.floor(18*uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(2*uiScale)
                }).setOrigin(0, 0.5);
                
                this.add.text(x + width/2 - 20*uiScale, y, value, {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(18*uiScale)}px`,
                    color: '#feca57',
                    stroke: '#000000',
                    strokeThickness: Math.floor(3*uiScale)
                }).setOrigin(1, 0.5);
            }

            createBackButton(x, y, uiScale) {
                const size = 48*uiScale;
                this.add.rectangle(x+2, y+2, size*2, size, 0x000000, 0.3);
                const btn = this.add.rectangle(x, y, size*2, size, 0x5f27cd).setInteractive();
                btn.setStrokeStyle(3*uiScale, 0x341f97);

                this.add.text(x, y, 'BACK', {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(18*uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(3*uiScale)
                }).setOrigin(0.5);

                btn.on('pointerdown', () => {
                    this.cameras.main.flash(200);
                    this.time.delayedCall(200, () => this.scene.start('MainMenu'));
                });
            }
        }

        class DailyChallengeMenuScene extends Phaser.Scene {
            constructor() {
                super('DailyChallengeMenu');
            }

            create() {
                const {width, height} = this.cameras.main;
                const minDim = Math.min(width, height);
                const uiScale = minDim / 750;
                const todayDate = getTodayDate();

                drawBricks(this, width, height);

                this.add.rectangle(width/2, height*0.12, width, height*0.12, 0x2d3561);
                this.add.text(width/2, height*0.06, 'DAILY CHALLENGE', {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(32*uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(6*uiScale)
                }).setOrigin(0.5);

                this.add.text(width/2, height*0.10, todayDate, {
                    fontFamily: 'Arial',
                    fontSize: `${Math.floor(18*uiScale)}px`,
                    color: '#feca57'
                }).setOrigin(0.5);

                // Mode selector tabs
                this.createModeTabs(width/2, height*0.18, uiScale);

                // Grid size buttons
                const sizes = [3, 4, 5, 6];
                const startY = height * 0.30;
                const spacing = height * 0.15;

                sizes.forEach((size, i) => {
                    const y = startY + i * spacing;
                    const isClassicCompleted = isDailyChallengeCompleted(todayDate, size, 'classic');
                    const isScrambleCompleted = isDailyChallengeCompleted(todayDate, size, 'scramble');
                    const classicData = getDailyChallengeData(todayDate, size, 'classic');
                    const scrambleData = getDailyChallengeData(todayDate, size, 'scramble');

                    this.createChallengeButton(width/2, y, size, isClassicCompleted, isScrambleCompleted, 
                                               classicData, scrambleData, uiScale);
                });

                this.createBackButton(48*uiScale, 48*uiScale, uiScale);
            }

            createModeTabs(x, y, uiScale) {
                // This is now just informational text since both modes are shown together
                this.add.text(x, y, 'Complete both Classic & Scramble for each size!', {
                    fontFamily: 'Arial',
                    fontSize: `${Math.floor(16*uiScale)}px`,
                    color: '#feca57',
                    stroke: '#000000',
                    strokeThickness: Math.floor(2*uiScale)
                }).setOrigin(0.5);
            }

            createChallengeButton(x, y, size, isClassicCompleted, isScrambleCompleted, classicData, scrambleData, uiScale) {
                const container = this.add.container(x, y);

                // Main button background
                const allCompleted = isClassicCompleted && isScrambleCompleted;
                const someCompleted = isClassicCompleted || isScrambleCompleted;
                const hasData = classicData && scrambleData;
                
                const bgColor = allCompleted ? 0x1dd1a1 : (someCompleted ? 0xFECA57 : (hasData ? 0x48DBFB : 0x64748b));
                const borderColor = allCompleted ? 0x10ac84 : (someCompleted ? 0xF97F51 : (hasData ? 0x0ABDE3 : 0x475569));

                const shadow = this.add.rectangle(6, 6, 360, 100, 0x000000, 0.3).setOrigin(0.5);
                const bg = this.add.rectangle(0, 0, 360, 100, bgColor).setOrigin(0.5);
                bg.setStrokeStyle(4*uiScale, borderColor);

                const text = this.add.text(-150, -20, `${size}Ã—${size} GRID`, {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(24*uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(4*uiScale)
                }).setOrigin(0, 0.5);

                // Classic status
                const classicStatus = isClassicCompleted ? 'âœ“' : (classicData ? 'â–¶' : 'ðŸ”’');
                const classicColor = isClassicCompleted ? '#1dd1a1' : (classicData ? '#ffffff' : '#999999');
                const classicBtn = this.add.text(-150, 20, `Classic ${classicStatus}`, {
                    fontFamily: 'Arial',
                    fontSize: `${Math.floor(16*uiScale)}px`,
                    color: classicColor,
                    stroke: '#000000',
                    strokeThickness: Math.floor(2*uiScale)
                }).setOrigin(0, 0.5);

                // Scramble status
                const scrambleStatus = isScrambleCompleted ? 'âœ“' : (scrambleData ? 'â–¶' : 'ðŸ”’');
                const scrambleColor = isScrambleCompleted ? '#1dd1a1' : (scrambleData ? '#ffffff' : '#999999');
                const scrambleBtn = this.add.text(50, 20, `Scramble ${scrambleStatus}`, {
                    fontFamily: 'Arial',
                    fontSize: `${Math.floor(16*uiScale)}px`,
                    color: scrambleColor,
                    stroke: '#000000',
                    strokeThickness: Math.floor(2*uiScale)
                }).setOrigin(0, 0.5);

                container.add([shadow, bg, text, classicBtn, scrambleBtn]);
                container.setSize(360, 100);

                // Make interactive if either mode is available and not completed
                if((classicData && !isClassicCompleted) || (scrambleData && !isScrambleCompleted)) {
                    container.setInteractive();

                    container.on('pointerdown', (pointer) => {
                        // Determine which mode was clicked based on x position
                        const localX = pointer.x - x;
                        
                        if(localX < 0 && classicData && !isClassicCompleted) {
                            // Classic mode clicked
                            this.cameras.main.flash(200);
                            this.time.delayedCall(200, () => {
                                this.scene.start('ClassicMode', {gridSize: size, isDailyMode: true, isScrambleMode: false});
                            });
                        } else if(localX >= 0 && scrambleData && !isScrambleCompleted) {
                            // Scramble mode clicked
                            this.cameras.main.flash(200);
                            this.time.delayedCall(200, () => {
                                this.scene.start('ScrambleMode', {gridSize: size, isDailyMode: true});
                            });
                        }
                    });

                    container.on('pointerover', () => {
                        this.tweens.add({targets: container, scale: 1.05, duration: 100});
                    });

                    container.on('pointerout', () => {
                        this.tweens.add({targets: container, scale: 1, duration: 100});
                    });
                }
            }

            createBackButton(x, y, uiScale) {
                this.add.rectangle(x+2, y+2, 90, 50, 0x000000, 0.3);
                const btn = this.add.rectangle(x, y, 90, 50, 0x5f27cd).setInteractive();
                btn.setStrokeStyle(3*uiScale, 0x341f97);

                this.add.text(x, y, 'BACK', {
                    fontFamily: 'Arial Black',
                    fontSize: `${Math.floor(18*uiScale)}px`,
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: Math.floor(3*uiScale)
                }).setOrigin(0.5);

                btn.on('pointerdown', () => {
                    this.cameras.main.flash(200);
                    this.time.delayedCall(200, () => this.scene.start('MainMenu'));
                });
            }
        }

        class ScrambleModeScene extends Phaser.Scene {
            constructor() { 
                super('ScrambleMode');
                this.gridSize = 4;
                this.isDailyMode = false;
                this.todayDate = getTodayDate();
                this.startTime = null;
            }

            init(data) {
                this.gridSize = data.gridSize || 4;
                this.isDailyMode = data.isDailyMode || false;
                this.startTime = Date.now();
            }
            
            create() {
                const w = this.cameras.main.width, h = this.cameras.main.height;
                const minDim = Math.min(w, h);
                this.uiScale = minDim / 750;

                this.drawBricks(w, h);
                
                this.genPuzzle();
                
                const titleHeight = h * 0.12;
                this.add.rectangle(w/2, titleHeight/2, w, titleHeight, 0x2d3561);
                
                const titleText = this.isDailyMode ? 'DAILY SCRAMBLE' : 'SCRAMBLE MODE';
                this.add.text(w/2, titleHeight*0.35, titleText, {
                    fontSize:`${Math.floor(32*this.uiScale)}px`,
                    fontFamily:'Arial Black',
                    color:'#fff',
                    stroke:'#000',
                    strokeThickness:Math.floor(6*this.uiScale)
                }).setOrigin(0.5);

                if(this.isDailyMode) {
                    this.add.text(w/2, titleHeight*0.7, this.todayDate, {
                        fontFamily: 'Arial',
                        fontSize: `${Math.floor(14*this.uiScale)}px`,
                        color: '#feca57'
                    }).setOrigin(0.5);
                } else {
                    this.createGridSizeSelector(w/2, titleHeight*0.75);
                }
                
                const checkButtonHeight = 60 * this.uiScale;
                const bottomMargin = h * 0.02;
                const availableGridHeight = h - titleHeight - checkButtonHeight - bottomMargin - (h * 0.08);
                
                this.cellSize = Math.floor(Math.min(availableGridHeight / this.gridSize, w * 0.85 / this.gridSize));
                this.startX = (w - this.cellSize * this.gridSize) / 2;
                
                const topSpace = titleHeight + h * 0.02;
                const gridHeight = this.cellSize * this.gridSize;
                const bottomSpace = h - checkButtonHeight - bottomMargin - (h * 0.04);
                this.startY = topSpace + (bottomSpace - topSpace - gridHeight) / 2;
                
                this.cells=[]; this.cellTexts=[]; this.cellContainers=[];
                for(let r=0; r<this.gridSize; r++) {
                    this.cells[r]=[]; this.cellTexts[r]=[]; this.cellContainers[r]=[];
                    for(let c=0; c<this.gridSize; c++) {
                        const x = this.startX+c*this.cellSize;
                        const y = this.startY+r*this.cellSize;
                        const size = this.cellSize * 0.92;
                        
                        const con = this.add.container(x, y);
                        const col = COLORS[(r*this.gridSize+c)%10];
                        const sh = this.add.rectangle(4*this.uiScale, 4*this.uiScale, size, size, 0x000000, 0.3).setOrigin(0);
                        const cell = this.add.rectangle(0, 0, size, size, col).setOrigin(0).setStrokeStyle(4*this.uiScale, 0x1a1a2e);
                        const txt = this.add.text(size/2, size/2, this.grid[r][c], {
                            fontSize:`${Math.floor(this.cellSize*0.45)}px`,
                            fontFamily:'Arial Black',
                            color:'#fff',
                            stroke:'#000',
                            strokeThickness:Math.floor(4*this.uiScale)
                        }).setOrigin(0.5);
                        con.add([sh,cell,txt]).setSize(size, size).setInteractive();
                        this.input.setDraggable(con);
                        con.row=r; con.col=c;
                        this.cells[r][c]=cell; this.cellTexts[r][c]=txt; this.cellContainers[r][c]=con;
                    }
                }
                
                this.input.on('dragstart', (p,o) => { o.setDepth(100); this.tweens.add({targets:o, scale:1.1, duration:100}); });
                this.input.on('drag', (p,o,dx,dy) => { o.x=dx; o.y=dy; });
                this.input.on('dragend', (p,o) => {
                    const dr=Math.floor((p.y-this.startY)/this.cellSize), dc=Math.floor((p.x-this.startX)/this.cellSize);
                    if(dr>=0 && dr<this.gridSize && dc>=0 && dc<this.gridSize) this.swapCells(o.row, o.col, dr, dc);
                    const fx=this.startX+o.col*this.cellSize, fy=this.startY+o.row*this.cellSize;
                    this.tweens.add({targets:o, x:fx, y:fy, scale:1, duration:200, ease:'Back.easeOut'});
                    o.setDepth(0);
                });
                
                this.makeBackBtn(48*this.uiScale, 48*this.uiScale, () => {
                    if(this.isDailyMode) {
                        this.scene.start('DailyChallengeMenu');
                    } else {
                        this.scene.start('MainMenu');
                    }
                });
                this.makeCheckBtn(w/2, h-70*this.uiScale, () => this.checkSolution());
            }

            createGridSizeSelector(x, y) {
                const buttonWidth = 55*this.uiScale;
                const spacing = 15*this.uiScale;
                const sizes = [3,4,5,6];
                const startX = x - ((sizes.length*buttonWidth + (sizes.length-1)*spacing)/2);

                sizes.forEach((size, i) => {
                    const btnX = startX + i*(buttonWidth+spacing) + buttonWidth/2;
                    const isSelected = size === this.gridSize;

                    const btn = this.add.rectangle(btnX, y, buttonWidth, buttonWidth*0.85, 
                        isSelected ? 0x1dd1a1 : 0x64748b).setInteractive();
                    btn.setStrokeStyle(3*this.uiScale, isSelected ? 0x10ac84 : 0x475569);

                    this.add.text(btnX, y, `${size}Ã—${size}`, {
                        fontFamily: 'Arial Black',
                        fontSize: `${Math.floor(18*this.uiScale)}px`,
                        color: '#ffffff',
                        stroke: '#000000',
                        strokeThickness: Math.floor(3*this.uiScale)
                    }).setOrigin(0.5);

                    btn.on('pointerdown', () => {
                        if(size !== this.gridSize) {
                            this.scene.restart({gridSize: size});
                        }
                    });

                    btn.on('pointerover', () => {
                        if(size !== this.gridSize) {
                            this.tweens.add({targets: btn, scaleX: 1.1, scaleY: 1.1, duration: 100});
                        }
                    });

                    btn.on('pointerout', () => {
                        this.tweens.add({targets: btn, scaleX: 1, scaleY: 1, duration: 100});
                    });
                });
            }
            
            drawBricks(w, h) {
                const g = this.add.graphics();
                for(let y=0; y<h; y+=40) for(let x=0; x<w; x+=80) {
                    const off = (y/40)%2===0 ? 0 : 40;
                    g.fillStyle(0x1e3a5f, 1); g.fillRect(x+off, y, 76, 36);
                    g.lineStyle(2, 0x2d5a8f); g.strokeRect(x+off, y, 76, 36);
                }
            }
            
            genPuzzle() {
                // If daily mode, use the daily scramble from loaded data or fallback
                if(this.isDailyMode) {
                    const scrambleData = getDailyChallengeData(this.todayDate, this.gridSize, 'scramble');
                    if(scrambleData && scrambleData.solution) {
                        this.solution = scrambleData.solution.map(w => w.split(''));
                        this.grid = JSON.parse(JSON.stringify(this.solution));
                        
                        // Shuffle all letters
                        const letters = [];
                        for(let r=0; r<this.gridSize; r++) {
                            for(let c=0; c<this.gridSize; c++) {
                                letters.push(this.grid[r][c]);
                            }
                        }
                        
                        for(let i=letters.length-1; i>0; i--) { 
                            const j=Math.floor(Math.random()*(i+1)); 
                            [letters[i],letters[j]]=[letters[j],letters[i]]; 
                        }
                        
                        let idx=0;
                        for(let r=0; r<this.gridSize; r++) {
                            for(let c=0; c<this.gridSize; c++) {
                                this.grid[r][c]=letters[idx++];
                            }
                        }
                        return;
                    }
                }
                
                // Try to use pre-generated grids from grid pools
                if (GRID_POOLS && GRID_POOLS[this.gridSize] && GRID_POOLS[this.gridSize].grids) {
                    const grids = GRID_POOLS[this.gridSize].grids;
                    if (grids.length > 0) {
                        const randomGrid = Phaser.Math.RND.pick(grids);
                        this.solution = randomGrid.grid;
                        this.grid = JSON.parse(JSON.stringify(this.solution));
                        
                        // Shuffle all letters
                        const letters = [];
                        for(let r=0; r<this.gridSize; r++) {
                            for(let c=0; c<this.gridSize; c++) {
                                letters.push(this.grid[r][c]);
                            }
                        }
                        
                        for(let i=letters.length-1; i>0; i--) { 
                            const j=Math.floor(Math.random()*(i+1)); 
                            [letters[i],letters[j]]=[letters[j],letters[i]]; 
                        }
                        
                        let idx=0;
                        for(let r=0; r<this.gridSize; r++) {
                            for(let c=0; c<this.gridSize; c++) {
                                this.grid[r][c]=letters[idx++];
                            }
                        }
                        console.log(`Using pre-generated ${this.gridSize}x${this.gridSize} scramble from pool`);
                        return;
                    }
                }
                
                // Fallback to hardcoded scrambles
                const scrambles = {
                    3: ['CAT', 'ATE', 'TEN'],
                    4: ['CATS', 'ANTS', 'TARS', 'STAR'],
                    5: ['HEART', 'EARTH', 'AFTER', 'RIVER', 'TREES'],
                    6: ['PLAYER', 'LISTEN', 'ARTIST', 'YEASTS', 'ENLIST', 'RESENT']
                };

                const words = scrambles[this.gridSize] || scrambles[4];
                this.solution = words.map(w => w.split(''));
                this.grid = JSON.parse(JSON.stringify(this.solution));
                
                // Shuffle all letters
                const letters = [];
                for(let r=0; r<this.gridSize; r++) {
                    for(let c=0; c<this.gridSize; c++) {
                        letters.push(this.grid[r][c]);
                    }
                }
                
                for(let i=letters.length-1; i>0; i--) { 
                    const j=Math.floor(Math.random()*(i+1)); 
                    [letters[i],letters[j]]=[letters[j],letters[i]]; 
                }
                
                let idx=0;
                for(let r=0; r<this.gridSize; r++) {
                    for(let c=0; c<this.gridSize; c++) {
                        this.grid[r][c]=letters[idx++];
                    }
                }
            }
            
            swapCells(r1,c1,r2,c2) {
                if(r1===r2 && c1===c2) return;
                [this.grid[r1][c1], this.grid[r2][c2]] = [this.grid[r2][c2], this.grid[r1][c1]];
                [this.cellContainers[r1][c1].row, this.cellContainers[r2][c2].row] = [this.cellContainers[r2][c2].row, this.cellContainers[r1][c1].row];
                [this.cellContainers[r1][c1].col, this.cellContainers[r2][c2].col] = [this.cellContainers[r2][c2].col, this.cellContainers[r1][c1].col];
                [this.cellContainers[r1][c1], this.cellContainers[r2][c2]] = [this.cellContainers[r2][c2], this.cellContainers[r1][c1]];
                const tx=this.startX+c1*this.cellSize, ty=this.startY+r1*this.cellSize;
                this.tweens.add({targets:this.cellContainers[r1][c1], x:tx, y:ty, duration:200, ease:'Back.easeOut'});
            }
            
            makeBackBtn(x, y, fn) {
                const size = 48*this.uiScale;
                this.add.rectangle(x+2, y+2, size*2, size, 0x000000, 0.3);
                const b = this.add.rectangle(x, y, size*2, size, 0x5F27CD).setStrokeStyle(3*this.uiScale, 0x341f97).setInteractive();
                this.add.text(x, y, 'BACK', {
                    fontSize:`${Math.floor(16*this.uiScale)}px`,
                    fontFamily:'Arial Black',
                    color:'#fff',
                    stroke:'#000',
                    strokeThickness:Math.floor(3*this.uiScale)
                }).setOrigin(0.5);
                b.on('pointerdown', () => { this.cameras.main.flash(200); this.time.delayedCall(200, fn); });
            }
            
            makeCheckBtn(x, y, fn) {
                const buttonWidth = this.cameras.main.width * 0.7;
                const buttonHeight = 55 * this.uiScale;
                
                this.add.rectangle(x+3, y+3, buttonWidth, buttonHeight, 0x000000, 0.3);
                const b = this.add.rectangle(x, y, buttonWidth, buttonHeight, 0x1DD1A1).setStrokeStyle(4*this.uiScale, 0x10ac84).setInteractive();
                const t = this.add.text(x, y, 'CHECK SOLUTION âœ“', {
                    fontSize:`${Math.floor(20*this.uiScale)}px`,
                    fontFamily:'Arial Black',
                    color:'#fff',
                    stroke:'#000',
                    strokeThickness:Math.floor(4*this.uiScale)
                }).setOrigin(0.5);
                b.on('pointerdown', () => { this.tweens.add({targets:[b,t], y:y+3, duration:50, yoyo:true}); fn(); });
                
                b.on('pointerover', () => {
                    this.tweens.add({targets: b, scaleX: 1.02, scaleY: 1.02, duration: 100});
                });

                b.on('pointerout', () => {
                    this.tweens.add({targets: b, scaleX: 1, scaleY: 1, duration: 100});
                });
            }
            
            checkSolution() {
                let valid = true;
                for(let r=0; r<this.gridSize; r++) {
                    if(!VALID_WORDS.has(this.grid[r].join('').toLowerCase())) valid=false;
                }
                for(let c=0; c<this.gridSize; c++) {
                    if(!VALID_WORDS.has(this.grid.map(r=>r[c]).join('').toLowerCase())) valid=false;
                }
                
                if(valid) {
                    // Update statistics
                    const elapsedTime = Math.floor((Date.now() - this.startTime) / 1000);
                    gameStats.gamesPlayed++;
                    gameStats.gamesWon++;
                    gameStats.totalTime += elapsedTime;
                    gameStats.bestTime = Math.min(gameStats.bestTime, elapsedTime);
                    gameStats.gridSizeStats[this.gridSize].played++;
                    gameStats.gridSizeStats[this.gridSize].won++;
                    
                    if(this.isDailyMode) {
                        markDailyChallengeCompleted(this.todayDate, this.gridSize, 'scramble');
                        gameStats.currentStreak++;
                        gameStats.maxStreak = Math.max(gameStats.maxStreak, gameStats.currentStreak);
                    }
                    
                    this.showVictory(elapsedTime);
                } else {
                    gameStats.gamesPlayed++;
                    gameStats.gridSizeStats[this.gridSize].played++;
                    this.showError();
                }
            }
            
            showVictory(elapsedTime) {
                const w = this.cameras.main.width, h = this.cameras.main.height;
                for(let i=0; i<40; i++) {
                    const emj = ['â­','ðŸŽ‰','âœ¨','ðŸŒŸ'][Phaser.Math.Between(0,3)];
                    const s = this.add.text(Phaser.Math.Between(0,w), Phaser.Math.Between(0,h), emj, {fontSize:'30px'});
                    this.tweens.add({targets:s, scale:2, alpha:0, angle:360, duration:1500, onComplete:()=>s.destroy()});
                }
                this.add.rectangle(w/2, h/2, w, h, 0x000000, 0.7);
                const t = this.add.text(w/2, h/2 - 40, 'ðŸŽ‰ SOLVED! ðŸŽ‰', {fontSize:'56px', fontFamily:'Arial Black', color:'#48DBFB', stroke:'#000', strokeThickness:8}).setOrigin(0.5);
                this.tweens.add({targets:t, scale:1.2, duration:500, yoyo:true, repeat:-1});
                
                // Show time
                const minutes = Math.floor(elapsedTime / 60);
                const seconds = elapsedTime % 60;
                const timeStr = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
                this.add.text(w/2, h/2 + 20, timeStr, {
                    fontFamily: 'Arial Black',
                    fontSize: '24px',
                    color: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 4
                }).setOrigin(0.5);
            }
            
            showError() {
                const w = this.cameras.main.width;
                const bg = this.add.rectangle(w/2, 90, 300, 50, 0xFF6B6B).setStrokeStyle(3, 0xEE5A6F);
                const t = this.add.text(w/2, 90, 'Keep trying!', {fontSize:'24px', fontFamily:'Arial Black', color:'#fff', stroke:'#000', strokeThickness:4}).setOrigin(0.5);
                this.tweens.add({targets:[bg,t], alpha:0, y:70, duration:2000, onComplete:()=>{ bg.destroy(); t.destroy(); }});
            }
        }

        const config = {
            type: Phaser.AUTO,
            width: Math.min(600, window.innerWidth),
            height: Math.min(1280, window.innerHeight),
            parent: 'game-container',
            backgroundColor: '#1a1a2e',
            scene: [MainMenuScene, DailyChallengeMenuScene, ClassicModeScene, ScrambleModeScene, StatsScene],
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            }
        };

        new Phaser.Game(config);
    </script>
</body>
</html>